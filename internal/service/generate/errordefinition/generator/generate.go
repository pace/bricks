package generator

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strconv"
	"strings"

	"github.com/dave/jennifer/jen"

	"github.com/pace/bricks/http/jsonapi/runtime"
)

const (
	pkgBricksErrors = "github.com/pace/bricks/maintenance/errors"
)

// Generator for go error types for the given json api error definition.
type Generator struct {
	goSource    *jen.File
	serviceName string
}

func loadDefinitionData(source string) ([]byte, error) {
	var data []byte
	if strings.HasPrefix(source, "http://") || strings.HasPrefix(source, "https://") {
		loc, err := url.Parse(source)
		if err != nil {
			return nil, err
		}

		data, err = loadDefinitionDataFromURI(loc)
		if err != nil {
			return nil, err
		}
	} else {
		// read definition file from disk
		var err error
		data, err = os.ReadFile(source) // nolint: gosec
		if err != nil {
			return nil, err
		}
	}

	return data, nil
}

func loadDefinitionDataFromURI(url *url.URL) ([]byte, error) {
	resp, err := http.Get(url.String())
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close() // nolint: errcheck

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return body, nil
}

// BuildSource generates the go code in the specified path with specified package name
// based on the passed schema source (url or file path)
func (g *Generator) BuildSource(source, packagePath, packageName string) (string, error) {
	data, err := loadDefinitionData(source)
	if err != nil {
		return "", err
	}

	// parse definition
	var errors runtime.Errors
	err = json.Unmarshal(data, &errors)
	if err != nil {
		return "", err
	}

	return g.BuildDefinitions(errors, packagePath, packageName)
}

func (g *Generator) BuildDefinitions(errors runtime.Errors, packagePath, packageName string) (string, error) {

	g.goSource = jen.NewFilePathName(packagePath, packageName)
	g.goSource.PackageComment("// Code generated by github.com/pace/bricks DO NOT EDIT.")

	g.serviceName = packageName

	// create a error code const for easier runtime error comparison

	var constObjects []jen.Code
	for _, jsonError := range errors {

		// skip example if given
		if jsonError.Code == "EXAMPLE" {
			continue
		}

		constObjects = append(constObjects, jen.Id(fmt.Sprintf("ERR_CODE_%s", jsonError.Code)).Op("=").Lit(jsonError.Code))

	}

	if len(constObjects) > 0 {
		g.goSource.Const().Defs(constObjects...)
	}

	for _, jsonError := range errors {

		// skip example if given
		if jsonError.Code == "EXAMPLE" {
			continue
		}

		httpStatusCode, err := strconv.Atoi(jsonError.Status)
		if err != nil {
			return "", fmt.Errorf("%w: unable to parse given http status code", err)
		}

		// create the err function

		g.goSource.Func().Id(fmt.Sprintf("ERR_%s", jsonError.Code)).Params(
			jen.Id("opts").Op("...").Qual(pkgBricksErrors, "BricksErrorOption"),
		).Params(
			jen.Op("*").Qual(pkgBricksErrors, "BricksError"),
		).Block(
			jen.Id("defaultOpts").Op(":=").Index().Qual(pkgBricksErrors, "BricksErrorOption").Values(
				jen.Qual(pkgBricksErrors, "WithStatus").Call(jen.Lit(httpStatusCode)),
				jen.Qual(pkgBricksErrors, "WithCode").Call(jen.Id(fmt.Sprintf("ERR_CODE_%s", jsonError.Code))),
				jen.Qual(pkgBricksErrors, "WithTitle").Call(jen.Lit(jsonError.Title))),
			jen.Id("defaultOpts").Op("=").Id("append").Call(jen.Id("defaultOpts"), jen.Id("opts").Op("...")),
			jen.Return(
				jen.Qual(pkgBricksErrors, "NewBricksError").Call(jen.Id("defaultOpts").Op("...")),
			),
		)

		g.goSource.Line()
	}

	return fmt.Sprintf("%#v", g.goSource), nil

}
