package generator

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"os"
	"strings"

	"github.com/dave/jennifer/jen"
)

// JSONErrors is a list of JSONError
type JSONErrors []JSONError

// JSONError is an open API conform json error object
type JSONError struct {
	ID     string `json:"id"`
	Origin string `json:"origin"`
	Links  []struct {
		About string `json:"about,omitempty"`
		Type  string `json:"type,omitempty"`
	} `json:"links"`
	Status int    `json:"status"`
	Code   string `json:"code"`
	Title  string `json:"title"`
	Detail string `json:"detail"`
	Source []struct {
		Pointer   string `json:"pointer,omitempty"`
		Parameter string `json:"parameter,omitempty"`
		Header    string `json:"header,omitempty"`
	} `json:"source"`
	Meta string `json:"meta"`
}

// Generator for go error types for the given json api error definition.
type Generator struct {
	goSource    *jen.File
	serviceName string
}

func loadDefinitionDataFromURI(url *url.URL) ([]byte, error) {
	resp, err := http.Get(url.String())
	if err != nil {
		return nil, err
	}
	defer resp.Body.Close() // nolint: errcheck

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, err
	}
	return body, nil
}

// BuildSource generates the go code in the specified path with specified package name
// based on the passed schema source (url or file path)
func (g *Generator) BuildSource(source, packagePath, packageName string) (string, error) {

	var data []byte
	if strings.HasPrefix(source, "http://") || strings.HasPrefix(source, "https://") {
		loc, err := url.Parse(source)
		if err != nil {
			return "", err
		}

		data, err = loadDefinitionDataFromURI(loc)
		if err != nil {
			return "", err
		}
	} else {
		// read definition file from disk
		var err error
		data, err = os.ReadFile(source) // nolint: gosec
		if err != nil {
			return "", err
		}

	}

	// parse definition
	var errors JSONErrors
	err := json.Unmarshal(data, &errors)
	if err != nil {
		return "", err
	}

	return g.BuildDefinitions(errors, packagePath, packageName)
}

func (g *Generator) BuildDefinitions(errors JSONErrors, packagePath, packageName string) (string, error) {

	g.goSource = jen.NewFilePathName(packagePath, packageName)
	g.goSource.PackageComment("// Code generated by github.com/pace/bricks DO NOT EDIT.")

	g.serviceName = packageName

	for _, jsonError := range errors {
		// generate error struct
		g.goSource.Type().Id(jsonError.Code).Struct(
			jen.Id("Status").Int(),
			jen.Id("Code").String(),
			jen.Id("Title").String(),
			jen.Id("Origin").String(),
			jen.Id("Err").Error(),
		)

		g.goSource.Func().Params(
			jen.Id("e").Op("*").Id(jsonError.Code),
		).Id("Error").Params().String().Block(
			jen.Return(
				jen.Qual("fmt", "Sprintf").Call(
					jen.Lit("%d, %s, %s, %s : %s"),
					jen.Id("e").Dot("Status"),
					jen.Id("e").Dot("Code"),
					jen.Id("e").Dot("Title"),
					jen.Id("e").Dot("Origin"),
					jen.Id("e").Dot("Err").Dot("Error").Call(),
				),
			),
		)
	}

	return fmt.Sprintf("%#v", g.goSource), nil

}
