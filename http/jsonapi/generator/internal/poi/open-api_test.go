// Code generated by github.com/pace/bricks DO NOT EDIT.
package poi

import (
	"context"
	errors1 "errors"
	mux "github.com/gorilla/mux"
	opentracing "github.com/opentracing/opentracing-go"
	runtime "github.com/pace/bricks/http/jsonapi/runtime"
	oauth2 "github.com/pace/bricks/http/oauth2"
	oidc "github.com/pace/bricks/http/oidc"
	apikey "github.com/pace/bricks/http/security/apikey"
	errors "github.com/pace/bricks/maintenance/errors"
	metrics "github.com/pace/bricks/maintenance/metric/jsonapi"
	decimal "github.com/shopspring/decimal"
	"net/http"
	"time"
)

// AppPOIsRelationshipsItem ...
type AppPOIsRelationshipsItem struct {
	ID string `jsonapi:"primary,pois,omitempty" valid:"uuid,optional"` // ID of the for the referenced object
}

// AppPOIsRelationships ...
type AppPOIsRelationships []*AppPOIsRelationshipsItem

// Categories ...
type Categories []*Category

// Category ...
type Category struct {
	ID          string   `jsonapi:"primary,category,omitempty" valid:"optional"`
	Available   []string `json:"available,omitempty" jsonapi:"attr,available,omitempty" valid:"optional"`
	Field       string   `json:"field,omitempty" jsonapi:"attr,field,omitempty" valid:"optional"`         // Example: "pm"
	FieldName   string   `json:"fieldName,omitempty" jsonapi:"attr,fieldName,omitempty" valid:"optional"` // Example: "paymentMethods"
	Unavailable []string `json:"unavailable,omitempty" jsonapi:"attr,unavailable,omitempty" valid:"optional"`
}

// CommonCountryID Country this policy applies to (as ISO3166Alpha2)
type CommonCountryID string

// CommonGeoJSONPoint https://tools.ietf.org/html/rfc7946#section-3.1.2
type CommonGeoJSONPoint struct {
	Coordinates CommonLatLong `json:"coordinates,omitempty" jsonapi:"attr,coordinates,omitempty" valid:"optional"`
	Type        string        `json:"type,omitempty" jsonapi:"attr,type,omitempty" valid:"optional,in(Point|)"` // Example: "Point"
}

// CommonGeoJSONPolygon https://tools.ietf.org/html/rfc7946#section-3.1.6; used as [bounding box](https://tools.ietf.org/html/rfc7946#section-5)
type CommonGeoJSONPolygon struct {
	Coordinates []CommonLatLong `json:"coordinates,omitempty" jsonapi:"attr,coordinates,omitempty" valid:"optional"` // Example: "[[8.424 49.012] [9.34 49.1] [8.424 49.012]]"
	Type        string          `json:"type,omitempty" jsonapi:"attr,type,omitempty" valid:"optional,in(Polygon|)"`  // Example: "Polygon"
}

// CommonLatLong https://tools.ietf.org/html/rfc7946
type CommonLatLong []float32

// CommonOpeningHoursRulesTimespans ...
type CommonOpeningHoursRulesTimespans struct {
	From string `json:"from,omitempty" jsonapi:"attr,from,omitempty" valid:"optional"` // relative to the specified time zone (local time)
	To   string `json:"to,omitempty" jsonapi:"attr,to,omitempty" valid:"optional"`     // relative to the specified time zone (local time)
}

// CommonOpeningHoursRules ...
type CommonOpeningHoursRules struct {
	Action    string                             `json:"action,omitempty" jsonapi:"attr,action,omitempty" valid:"optional,in(open|close|)"`
	Days      []string                           `json:"days,omitempty" jsonapi:"attr,days,omitempty" valid:"optional,in(monday|tuesday|wednesday|thursday|friday|saturday|sunday|)"`
	Timespans []CommonOpeningHoursRulesTimespans `json:"timespans,omitempty" jsonapi:"attr,timespans,omitempty" valid:"optional"`
}

// CommonOpeningHours ...
type CommonOpeningHours struct {
	Rules    []CommonOpeningHoursRules `json:"rules,omitempty" jsonapi:"attr,rules,omitempty" valid:"optional"`
	Timezone string                    `json:"timezone,omitempty" jsonapi:"attr,timezone,omitempty" valid:"optional"` // As defined by ISO 8601, the timezone
}

// DedupeRequest ...
type DedupeRequest struct {
	ID         string   `jsonapi:"primary,dedupePoi,omitempty" valid:"uuid,optional"`                           // UUID of the POI that is considered as origin of all the other POI duplicate UUIDs
	Duplicates []string `json:"duplicates,omitempty" jsonapi:"attr,duplicates,omitempty" valid:"optional,uuid"` // UUIDs of the duplicate POIs
}

// Event ...
type Event struct {
	ID        string      `jsonapi:"primary,events,omitempty" valid:"uuid,optional"` // Event ID
	CreatedAt *time.Time  `json:"createdAt,omitempty" jsonapi:"attr,createdAt,omitempty,iso8601" valid:"optional"`
	EventAt   *time.Time  `json:"eventAt,omitempty" jsonapi:"attr,eventAt,omitempty,iso8601" valid:"optional"`
	Fields    []FieldData `json:"fields,omitempty" jsonapi:"attr,fields,omitempty" valid:"optional"`
	UserID    string      `json:"userId,omitempty" jsonapi:"attr,userId,omitempty" valid:"optional,uuid"` // Tracks who did last change
}

// Events ...
type Events []*Event

// FieldData ...
type FieldData struct {
	Field FieldName `json:"field,omitempty" jsonapi:"attr,field,omitempty" valid:"optional"`
	Value string    `json:"value,omitempty" jsonapi:"attr,value,omitempty" valid:"optional"` // escaped json
}

// FieldMetaData ...
type FieldMetaData struct {
	SourceID  string     `json:"SourceId,omitempty" jsonapi:"attr,SourceId,omitempty" valid:"optional,uuid"` // Source ID
	UpdatedAt *time.Time `json:"UpdatedAt,omitempty" jsonapi:"attr,UpdatedAt,omitempty,iso8601" valid:"optional"`
	Field     FieldName  `json:"field,omitempty" jsonapi:"attr,field,omitempty" valid:"optional"`
}

// FieldName ...
type FieldName string

// Fuel Fuel type for cars, based on the EU fuel marking
type Fuel string

// FuelPrice ...
type FuelPrice struct {
	ID          string           `jsonapi:"primary,fuelPrice,omitempty" valid:"uuid,optional"` // Fuel Price ID
	Currency    Currency         `json:"currency,omitempty" jsonapi:"attr,currency,omitempty" valid:"optional"`
	FuelType    Fuel             `json:"fuelType,omitempty" jsonapi:"attr,fuelType,omitempty" valid:"optional"`
	Price       *decimal.Decimal `json:"price,omitempty" jsonapi:"attr,price,omitempty" valid:"optional"`                 // per liter
	ProductName string           `json:"productName,omitempty" jsonapi:"attr,productName,omitempty" valid:"optional"`     // Example: "Super E10"
	UpdatedAt   *time.Time       `json:"updatedAt,omitempty" jsonapi:"attr,updatedAt,omitempty,iso8601" valid:"optional"` // Time of FuelPrices last update iso8601 with microseconds UTC
}

// FuelPriceResponse ...
type FuelPriceResponse *FuelPrice

// FuelType ...
type FuelType struct {
	ID          string `jsonapi:"primary,fuelType,omitempty" valid:"optional"`                              // FuelType ID
	FuelType    string `json:"fuelType,omitempty" jsonapi:"attr,fuelType,omitempty" valid:"optional"`       // Normalized name, i.e., converted to a fuel type.
	ProductName string `json:"productName,omitempty" jsonapi:"attr,productName,omitempty" valid:"optional"` // Product name.
}

// GasStationAddress ...
type GasStationAddress struct {
	City        string `json:"city,omitempty" jsonapi:"attr,city,omitempty" valid:"optional"`               // Example: "Karlsruhe"
	CountryCode string `json:"countryCode,omitempty" jsonapi:"attr,countryCode,omitempty" valid:"optional"` // Country code in as specified in ISO 3166-1.
	HouseNo     string `json:"houseNo,omitempty" jsonapi:"attr,houseNo,omitempty" valid:"optional"`         // Example: "18"
	PostalCode  string `json:"postalCode,omitempty" jsonapi:"attr,postalCode,omitempty" valid:"optional"`   // Example: "76131"
	Street      string `json:"street,omitempty" jsonapi:"attr,street,omitempty" valid:"optional"`           // Example: "Haid-und-Neu-Str."
}

// GasStationContact ...
type GasStationContact struct {
	Email       string `json:"email,omitempty" jsonapi:"attr,email,omitempty" valid:"optional"`              // Example: "max.mustermann@pace.de"
	FaxNumber   string `json:"faxNumber,omitempty" jsonapi:"attr,faxNumber,omitempty" valid:"optional"`      // Example: "+49-175-5559-723"
	FirstName   string `json:"firstName,omitempty" jsonapi:"attr,firstName,omitempty" valid:"optional"`      // Example: "Max"
	Gender      string `json:"gender,omitempty" jsonapi:"attr,gender,omitempty" valid:"optional,in(m|f|o|)"` // Example: "m"
	LastName    string `json:"lastName,omitempty" jsonapi:"attr,lastName,omitempty" valid:"optional"`        // Example: "Mustermann"
	PhoneNumber string `json:"phoneNumber,omitempty" jsonapi:"attr,phoneNumber,omitempty" valid:"optional"`  // Example: "+49-175-5559-722"
}

// GasStation ...
type GasStation struct {
	ID                string              `jsonapi:"primary,gasStation,omitempty" valid:"uuid,optional"` // Gas Station ID
	Address           GasStationAddress   `json:"address,omitempty" jsonapi:"attr,address,omitempty" valid:"optional"`
	Amenities         []string            `json:"amenities,omitempty" jsonapi:"attr,amenities,omitempty" valid:"optional,in(atm|disabilityFriendly|shop|shower|toilet|tollTerminal|carParking|truckParking|truckSuitable|unmanned|paymentTerminal|motel|)"` // Example: "[atm truckParking]"
	Brand             string              `json:"brand,omitempty" jsonapi:"attr,brand,omitempty" valid:"optional"`                                                                                                                                          // Example: "Total"
	Contact           GasStationContact   `json:"contact,omitempty" jsonapi:"attr,contact,omitempty" valid:"optional"`
	Food              []string            `json:"food,omitempty" jsonapi:"attr,food,omitempty" valid:"optional,in(bakery|bistro|cafe|restaurant|takeaway|)"`                                 // Example: "[restaurant bakery]"
	Latitude          float32             `json:"latitude" jsonapi:"attr,latitude" valid:"optional"`                                                                                         // Example: "49.013"
	Longitude         float32             `json:"longitude" jsonapi:"attr,longitude" valid:"optional"`                                                                                       // Example: "8.425"
	LoyaltyPrograms   []string            `json:"loyaltyPrograms,omitempty" jsonapi:"attr,loyaltyPrograms,omitempty" valid:"optional,in(deutschlandCard|payback|shellClubsmart|totalClub|)"` // Example: "[payback]"
	OpeningHours      CommonOpeningHours  `json:"openingHours,omitempty" jsonapi:"attr,openingHours,omitempty" valid:"optional"`
	PaymentMethods    []string            `json:"paymentMethods,omitempty" jsonapi:"attr,paymentMethods,omitempty" valid:"optional,in(americanExpress|applyPay|aralKomfort|aviaCard|barclays|bayWaCard|cash|dinersClub|dkv|essoCard|essoVoucher|euroshell|ffCard|girocard|googlePay|hemMycard|jetCard|logPay|maestro|masterCard|novofleet|pacePay|paypal|routex|sepaDirectDebit|starFleetCard|tndCard|totalCard|uta|visa|vPay|westfalenCard|)"` // Example: "[sepaDirectDebit visa]"
	PostalServices    []string            `json:"postalServices,omitempty" jsonapi:"attr,postalServices,omitempty" valid:"optional,in(dhl|dhlPackstation|dpd|gls|hermes|post|ups|)"`                                                                                                                                                                                                                                                            // Example: "[gls dhl]"
	PriceFormat       string              `json:"priceFormat,omitempty" jsonapi:"attr,priceFormat,omitempty" valid:"optional"`                                                                                                                                                                                                                                                                                                                  // Example: "d.dds"
	References        []string            `json:"references,omitempty" jsonapi:"attr,references,omitempty" valid:"optional"`                                                                                                                                                                                                                                                                                                                    // References are PRNs to external and internal resources that are represented by this poi
	Services          []string            `json:"services,omitempty" jsonapi:"attr,services,omitempty" valid:"optional,in(carWash|freeWifi|gasBottleRefill|gasStationAttendant|laundryService|lotto|oilService|paceConnectedFueling|screenWashWater|selfServiceCarWash|truckWash|twentyFourHoursFueling|twentyFourHoursShopping|tyreAir|tyreService|vacuum|wifi|workshop|)"`                                                                    // Example: "[wifi tyreAir]"
	ShopGoods         []string            `json:"shopGoods,omitempty" jsonapi:"attr,shopGoods,omitempty" valid:"optional,in(adBlue|contactLenses|crushedIce|flowers|vignette|lubricants|)"`
	StationName       string              `json:"stationName,omitempty" jsonapi:"attr,stationName,omitempty" valid:"optional"` // Example: "PACE Station"
	FuelPrices        []*FuelPrice        `json:"fuelPrices,omitempty" jsonapi:"relation,fuelPrices,omitempty" valid:"optional"`
	LocationBasedApps []*LocationBasedApp `json:"locationBasedApps,omitempty" jsonapi:"relation,locationBasedApps,omitempty" valid:"optional"`
	ReferenceStatuses []*ReferenceStatus  `json:"referenceStatuses,omitempty" jsonapi:"relation,referenceStatuses,omitempty" valid:"optional"`
	SucessorOf        []*GasStation       `json:"sucessorOf,omitempty" jsonapi:"relation,sucessorOf,omitempty" valid:"optional"`
}

// GasStations ...
type GasStations []*GasStation

// LocationBasedApp ...
type LocationBasedApp struct {
	ID                   string `jsonapi:"primary,locationBasedApp,omitempty" valid:"uuid,optional"`                                   // Location-based app ID
	AndroidInstantAppURL string `json:"androidInstantAppUrl,omitempty" jsonapi:"attr,androidInstantAppUrl,omitempty" valid:"optional"` // Android instant app URL
	AppType              string `json:"appType,omitempty" jsonapi:"attr,appType,omitempty" valid:"optional,in(fueling|)"`
	Cache                string `json:"cache,omitempty" jsonapi:"attr,cache,omitempty" valid:"optional,in(approaching|preload|)"` /*
		A location-based app is by default loaded on `approaching`. Some apps should be loaded in advance. They have the cache set to `preload`.
	*/
	CreatedAt *time.Time `json:"createdAt,omitempty" jsonapi:"attr,createdAt,omitempty,iso8601" valid:"optional"` // Time of LocationBasedApp creation (iso8601 without time zone)
	DeletedAt *time.Time `json:"deletedAt,omitempty" jsonapi:"attr,deletedAt,omitempty,iso8601" valid:"optional"` // Time of LocationBasedApp deletion (iso8601 without time zone)
	LogoURL   string     `json:"logoUrl,omitempty" jsonapi:"attr,logoUrl,omitempty" valid:"optional"`             // Logo URL
	PwaURL    string     `json:"pwaUrl,omitempty" jsonapi:"attr,pwaUrl,omitempty" valid:"optional"`               /*
		Progressive web application URL. The URL satisfies the following criteria: <li>The URL responds with `text/html` on a GET request</li> <li>The response contains HTTP caching headers e.g. `Cache-Control` and `ETag`</li> <li>HTTP GET request on the URL with an `ETag` will return `304` (`Not Modified`), if the content didn't change</li> <li>If `503` (`Service Unavailable`) is returned the request should be retried later</li> <li>If `404` (`Not Found`) is returned the URL is invalidated and a new app should be requested</li>
	*/
	Subtitle  string     `json:"subtitle,omitempty" jsonapi:"attr,subtitle,omitempty" valid:"optional"`           // Example: "Zahle bargeldlos mit der PACE Fueling App"
	Title     string     `json:"title,omitempty" jsonapi:"attr,title,omitempty" valid:"optional"`                 // Example: "PACE Fueling App"
	UpdatedAt *time.Time `json:"updatedAt,omitempty" jsonapi:"attr,updatedAt,omitempty,iso8601" valid:"optional"` // Time of LocationBasedApp last update (iso8601 without time zone)
}

// LocationBasedAppWithRefs ...
type LocationBasedAppWithRefs struct {
	ID                   string `jsonapi:"primary,locationBasedAppWithRefs,omitempty" valid:"uuid,optional"`                           // Location-based app ID
	AndroidInstantAppURL string `json:"androidInstantAppUrl,omitempty" jsonapi:"attr,androidInstantAppUrl,omitempty" valid:"optional"` // Android instant app URL
	AppType              string `json:"appType,omitempty" jsonapi:"attr,appType,omitempty" valid:"optional,in(fueling|)"`
	Cache                string `json:"cache,omitempty" jsonapi:"attr,cache,omitempty" valid:"optional,in(approaching|preload|)"` /*
		A location-based app is by default loaded on `approaching`. Some apps should be loaded in advance. They have the cache set to `preload`.
	*/
	CreatedAt *time.Time `json:"createdAt,omitempty" jsonapi:"attr,createdAt,omitempty,iso8601" valid:"optional"` // Time of LocationBasedApp creation (iso8601 without time zone)
	DeletedAt *time.Time `json:"deletedAt,omitempty" jsonapi:"attr,deletedAt,omitempty,iso8601" valid:"optional"` // Time of LocationBasedApp deletion (iso8601 without time zone)
	LogoURL   string     `json:"logoUrl,omitempty" jsonapi:"attr,logoUrl,omitempty" valid:"optional"`             // Logo URL
	PwaURL    string     `json:"pwaUrl,omitempty" jsonapi:"attr,pwaUrl,omitempty" valid:"optional"`               /*
		Progressive web application URL. The URL satisfies the following criteria: <li>The URL responds with `text/html` on a GET request</li> <li>The response contains HTTP caching headers e.g. `Cache-Control` and `ETag`</li> <li>HTTP GET request on the URL with an `ETag` will return `304` (`Not Modified`), if the content didn't change</li> <li>If `503` (`Service Unavailable`) is returned the request should be retried later</li> <li>If `404` (`Not Found`) is returned the URL is invalidated and a new app should be requested</li>
	*/
	References []string   `json:"references,omitempty" jsonapi:"attr,references,omitempty" valid:"optional"`       // References are PRNs to external and internal resources that are related to the query
	Subtitle   string     `json:"subtitle,omitempty" jsonapi:"attr,subtitle,omitempty" valid:"optional"`           // Example: "Zahle bargeldlos mit der PACE Fueling App"
	Title      string     `json:"title,omitempty" jsonapi:"attr,title,omitempty" valid:"optional"`                 // Example: "PACE Fueling App"
	UpdatedAt  *time.Time `json:"updatedAt,omitempty" jsonapi:"attr,updatedAt,omitempty,iso8601" valid:"optional"` // Time of LocationBasedApp last update (iso8601 without time zone)
}

// LocationBasedApps ...
type LocationBasedApps []*LocationBasedApp

// LocationBasedAppsWithRefs ...
type LocationBasedAppsWithRefs []*LocationBasedAppWithRefs

// MoveRequest Creates a new event object at lat/lng from this POI ID
type MoveRequest struct {
	ID        string  `jsonapi:"primary,movePoi,omitempty" valid:"uuid,optional"`  // UUID of the POI that is going to be moved
	Latitude  float32 `json:"latitude" jsonapi:"attr,latitude" valid:"optional"`   // Latitude in degrees
	Longitude float32 `json:"longitude" jsonapi:"attr,longitude" valid:"optional"` // Longitude in degrees
}

// POI ...
type POI struct {
	ID                string               `jsonapi:"primary,GasStation,omitempty" valid:"uuid,optional"` // POI ID
	Active            bool                 `json:"active" jsonapi:"attr,active" valid:"optional"`
	Boundary          CommonGeoJSONPolygon `json:"boundary,omitempty" jsonapi:"attr,boundary,omitempty" valid:"optional"`
	CountryID         CommonCountryID      `json:"countryId,omitempty" jsonapi:"attr,countryId,omitempty" valid:"optional"`
	CreatedAt         *time.Time           `json:"createdAt,omitempty" jsonapi:"attr,createdAt,omitempty,iso8601" valid:"optional"`
	Data              []FieldData          `json:"data,omitempty" jsonapi:"attr,data,omitempty" valid:"optional"` // a JSON field containing POI specific data
	LastSeenAt        *time.Time           `json:"lastSeenAt,omitempty" jsonapi:"attr,lastSeenAt,omitempty,iso8601" valid:"optional"`
	Metadata          []FieldMetaData      `json:"metadata,omitempty" jsonapi:"attr,metadata,omitempty" valid:"optional"` // a JSON field containing information about data field origin and update time
	Position          CommonGeoJSONPoint   `json:"position,omitempty" jsonapi:"attr,position,omitempty" valid:"optional"`
	References        []string             `json:"references,omitempty" jsonapi:"attr,references,omitempty" valid:"optional"` // References are PRNs to external and internal resources that are represented by this poi
	UpdatedAt         *time.Time           `json:"updatedAt,omitempty" jsonapi:"attr,updatedAt,omitempty,iso8601" valid:"optional"`
	ReferenceStatuses []*ReferenceStatus   `json:"referenceStatuses,omitempty" jsonapi:"relation,referenceStatuses,omitempty" valid:"optional"`
	SucessorOf        []*GasStation        `json:"sucessorOf,omitempty" jsonapi:"relation,sucessorOf,omitempty" valid:"optional"`
}

// POIType POI type this applies to
type POIType string

// POIs ...
type POIs []*POI

// Policies ...
type Policies []*Policy

// Policy ...
type Policy struct {
	ID        string          `jsonapi:"primary,policies,omitempty" valid:"uuid,optional"` // Policy ID
	CountryID CommonCountryID `json:"countryId,omitempty" jsonapi:"attr,countryId,omitempty" valid:"optional"`
	CreatedAt *time.Time      `json:"createdAt,omitempty" jsonapi:"attr,createdAt,omitempty,iso8601" valid:"optional"` // Time of POI creation in (iso8601 without zone - expects UTC)
	PoiType   POIType         `json:"poiType,omitempty" jsonapi:"attr,poiType,omitempty" valid:"optional"`
	Rules     []PolicyRule    `json:"rules,omitempty" jsonapi:"attr,rules,omitempty" valid:"optional"`
	UserID    string          `json:"userId,omitempty" jsonapi:"attr,userId,omitempty" valid:"optional,uuid"` // Tracks who did last change
}

// PolicyRule ...
type PolicyRule struct {
	Field      FieldName            `json:"field,omitempty" jsonapi:"attr,field,omitempty" valid:"required"`
	Priorities []PolicyRulePriority `json:"priorities,omitempty" jsonapi:"attr,priorities,omitempty" valid:"required"`
}

// PolicyRulePriority ...
type PolicyRulePriority struct {
	SourceID   string  `json:"sourceId,omitempty" jsonapi:"attr,sourceId,omitempty" valid:"required,uuid"` // Tracks who did last change
	TimeToLive float64 `json:"timeToLive" jsonapi:"attr,timeToLive" valid:"optional"`                      // Time to live in seconds (in relation to other entries)
}

// PriceHistoryFuelPrices ...
type PriceHistoryFuelPrices struct {
	At    *time.Time       `json:"at,omitempty" jsonapi:"attr,at,omitempty,iso8601" valid:"optional"` // The datetime of the price value
	Price *decimal.Decimal `json:"price,omitempty" jsonapi:"attr,price,omitempty" valid:"optional"`   // The price at this point in time
}

// PriceHistory ...
type PriceHistory struct {
	ID          string                   `jsonapi:"primary,priceHistory,omitempty" valid:"optional"` // Fuel Type
	Currency    Currency                 `json:"currency,omitempty" jsonapi:"attr,currency,omitempty" valid:"optional"`
	From        *time.Time               `json:"from,omitempty" jsonapi:"attr,from,omitempty,iso8601" valid:"optional"` // Beginning of time interval
	FuelPrices  []PriceHistoryFuelPrices `json:"fuelPrices,omitempty" jsonapi:"attr,fuelPrices,omitempty" valid:"optional"`
	ProductName string                   `json:"productName,omitempty" jsonapi:"attr,productName,omitempty" valid:"optional"` // Example: "Super E5"
	To          *time.Time               `json:"to,omitempty" jsonapi:"attr,to,omitempty,iso8601" valid:"optional"`           // End of time interval
}

// ReferenceStatus ...
type ReferenceStatus struct {
	ID     string `jsonapi:"primary,referenceStatus,omitempty" valid:"optional"`                                 // Service Provider PRN
	Status string `json:"status,omitempty" jsonapi:"attr,status,omitempty" valid:"optional,in(online|offline|)"` // Availability status of the referenced resource
}

// ReferenceStatuses ...
type ReferenceStatuses []*ReferenceStatus

// RegionalPricesItem Regional prices
type RegionalPricesItem struct {
	ID       string           `jsonapi:"primary,regionalPrices,omitempty" valid:"in(ron98|ron98e5|ron95e10|diesel|e85|ron91|ron95e5|ron100|dieselGtl|dieselB7|dieselPremium|lpg|cng|lng|h2|truckDiesel|adBlue|truckAdBlue|truckDieselPremium|truckLpg|heatingOil),optional"` // Fuel type for cars, based on the EU fuel marking
	Average  *decimal.Decimal `json:"average,omitempty" jsonapi:"attr,average,omitempty" valid:"optional"`                                                                                                                                                                   // Average price for this fuel type
	Currency string           `json:"currency,omitempty" jsonapi:"attr,currency,omitempty" valid:"optional"`                                                                                                                                                                 // Currency based on country
	Lower    *decimal.Decimal `json:"lower,omitempty" jsonapi:"attr,lower,omitempty" valid:"optional"`                                                                                                                                                                       // Price value indicator below which a price is considered cheap
	Upper    *decimal.Decimal `json:"upper,omitempty" jsonapi:"attr,upper,omitempty" valid:"optional"`                                                                                                                                                                       // Price value indicator after which a price is considered expensive
}

// RegionalPrices ...
type RegionalPrices []*RegionalPricesItem

// Source ...
type Source struct {
	ID         string      `jsonapi:"primary,sources,omitempty" valid:"uuid,optional"`                      // Source ID
	Countries  []string    `json:"countries,omitempty" jsonapi:"attr,countries,omitempty" valid:"optional"` // list of ISO-3166-1 ALPHA-2 encoded countries
	CreatedAt  *time.Time  `json:"createdAt,omitempty" jsonapi:"attr,createdAt,omitempty,iso8601" valid:"optional"`
	LastDataAt *time.Time  `json:"lastDataAt,omitempty" jsonapi:"attr,lastDataAt,omitempty,iso8601" valid:"optional"` // timestamp of last import from source
	Name       string      `json:"name,omitempty" jsonapi:"attr,name,omitempty" valid:"optional"`                     // source name, unique
	PoiType    POIType     `json:"poiType,omitempty" jsonapi:"attr,poiType,omitempty" valid:"optional"`
	Schema     []FieldName `json:"schema,omitempty" jsonapi:"attr,schema,omitempty" valid:"optional"` // JSON field describing the structure of the updates sent by the data source
	UpdatedAt  *time.Time  `json:"updatedAt,omitempty" jsonapi:"attr,updatedAt,omitempty,iso8601" valid:"optional"`
}

// Sources ...
type Sources []*Source

// SubscriptionConditionsFuelPrice Condition on the fuelPrice of a gas station.
type SubscriptionConditionsFuelPrice struct {
	Lt float64 `json:"lt" jsonapi:"attr,lt" valid:"optional"` /*
		Fuel price is less then given amount. Amount is always given in the currency of the gas station. The units are not scaled, for `EUR`, the value 1.3 means 1 euro and 30 cents.
	*/
}

// SubscriptionConditionsFuelType Condition on the fuelType of a gas station
type SubscriptionConditionsFuelType struct {
	Eq string `json:"eq,omitempty" jsonapi:"attr,eq,omitempty" valid:"optional,in(ron98|ron98e5|ron95e10|diesel|e85|ron91|ron95e5|ron100|dieselGtl|dieselB7|dieselB15|dieselPremium|lpg|cng|lng|h2|truckDiesel|adBlue|truckAdBlue|truckDieselPremium|truckLpg|heatingOil|)"` // Fuel type is equal to given value
}

/*
SubscriptionConditions Optional conditions to reduce the number of notifications to the device. For a notification to be fired, all conditions need to be true.
The example reads as `fuelPrice < 1.3 && fuelType == "diesel"`. For or conditions use multiple subscriptions.
*/
type SubscriptionConditions struct {
	FuelPrice SubscriptionConditionsFuelPrice `json:"fuelPrice,omitempty" jsonapi:"attr,fuelPrice,omitempty" valid:"optional"` // Condition on the fuelPrice of a gas station.
	FuelType  SubscriptionConditionsFuelType  `json:"fuelType,omitempty" jsonapi:"attr,fuelType,omitempty" valid:"optional"`   // Condition on the fuelType of a gas station
}

// Subscription ...
type Subscription struct {
	ID         string                 `jsonapi:"primary,subscription,omitempty" valid:"uuid,optional"`                   // POI Subscription ID
	Conditions SubscriptionConditions `json:"conditions,omitempty" jsonapi:"attr,conditions,omitempty" valid:"optional"` /*
		Optional conditions to reduce the number of notifications to the device. For a notification to be fired, all conditions need to be true.
		The example reads as `fuelPrice < 1.3 && fuelType == "diesel"`. For or conditions use multiple subscriptions.
	*/
	CreatedAt    *time.Time `json:"createdAt,omitempty" jsonapi:"attr,createdAt,omitempty,iso8601" valid:"optional"`    // Time of subscription creation (iso8601 without time zone)
	ExpiresAt    *time.Time `json:"expiresAt,omitempty" jsonapi:"attr,expiresAt,omitempty,iso8601" valid:"optional"`    // Time when the subscription will expire, must not be more then 60 days in the future (iso8601 without time zone)
	ObservedPois []string   `json:"observedPois,omitempty" jsonapi:"attr,observedPois,omitempty" valid:"required,uuid"` // Example: "[prn:pos:gas-stations:4d6dd9db-b0ac-40e8-a099-b606cace6f72 prn:pos:gas-stations:9536bb4a-6623-4b96-9bed-655f30c5b5cf prn:pos:gas-stations:f0fca287-94f7-47f7-8f5a-0fea0dccfaa6]"
	PushToken    string     `json:"pushToken,omitempty" jsonapi:"attr,pushToken,omitempty" valid:"required"`            // PRN describing the push token. E.g. FCM token.
	UpdatedAt    *time.Time `json:"updatedAt,omitempty" jsonapi:"attr,updatedAt,omitempty,iso8601" valid:"optional"`    // Time of LocationBasedApp last update (iso8601 without time zone)
}

// Currency ...
type Currency string

// FuelAmountUnit ...
type FuelAmountUnit string
type AuthorizationBackend interface {
	AuthorizeDeviceID(r *http.Request, w http.ResponseWriter) (context.Context, bool)
	InitDeviceID(cfgDeviceID *apikey.Config)
	AuthorizeOAuth2(r *http.Request, w http.ResponseWriter, scope string) (context.Context, bool)
	InitOAuth2(cfgOAuth2 *oauth2.Config)
	AuthorizeOIDC(r *http.Request, w http.ResponseWriter, scope string) (context.Context, bool)
	InitOIDC(cfgOIDC *oidc.Config)
}

var cfgDeviceID = &apikey.Config{
	Description: "Authentication using a unique device id. This is allows usage of the api without a user account. The device id has to be 32 bytes long and is best generated with a secure random function. E.g. `3b5cb427432aee46a2aa1dbad6f1c7629ec7928ce732afdd73ff7554b9c46272` generated using `openssl rand -hex 32`. The device id may not be the same across a re-install of the app. In case the device id is lost, all data stored with that device id is lost. If a device ID is not seen for a longer time period, the data may be deleted.\n",
	In:          "header",
	Name:        "Device-ID",
}
var cfgOAuth2 = &oauth2.Config{
	AuthorizationCode: &oauth2.Flow{
		AuthorizationURL: "https://id.pace.cloud/auth/realms/pace/protocol/openid-connect/auth",
		RefreshURL:       "https://id.pace.cloud/auth/realms/pace/protocol/openid-connect/token",
		Scopes: map[string]string{
			"poi:apps:create":                    "Create an app",
			"poi:apps:delete":                    "Delete an app",
			"poi:apps:read":                      "Get/search for an app",
			"poi:apps:update":                    "Change an app",
			"poi:events:read":                    "Get/search for events",
			"poi:gas-stations.references:read":   "Enabled additional reference data on the gas station",
			"poi:gas-stations.references:update": "Write additional reference data on the gas station",
			"poi:gas-stations:read":              "Get/search for gas stations",
			"poi:pois.references:read":           "Enabled additional reference data on the poi",
			"poi:pois:read":                      "Get/search for pois",
			"poi:pois:update":                    "Update a poi",
			"poi:policies:create":                "Create a policy",
			"poi:policies:read":                  "Get/search for policies",
			"poi:sources:create":                 "Create a source",
			"poi:sources:delete":                 "Delete a source",
			"poi:sources:read":                   "Get/search for sources",
			"poi:sources:update":                 "Update a source",
			"poi:subscriptions:create":           "Create a subscription",
			"poi:subscriptions:delete":           "Delete a subscription",
			"poi:subscriptions:read":             "List all subscriptions",
			"poi:tiles:read":                     "Get/search for tiles",
		},
		TokenURL: "https://id.pace.cloud/auth/realms/pace/protocol/openid-connect/token",
	},
	Description: "",
}
var cfgOIDC = &oidc.Config{
	Description:      "",
	OpenIdConnectURL: "https://id.pace.cloud/auth/realms/pace/.well-known/openid-configuration",
}

/*
DeduplicatePoiHandler handles request/response marshaling and validation for

	Patch /beta/admin/poi/dedupe
*/
func DeduplicatePoiHandler(service DeduplicatePoiHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("DeduplicatePoiHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:pois:update")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "DeduplicatePoiHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := deduplicatePoiResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/admin/poi/dedupe", w, r),
		}
		request := DeduplicatePoiRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.DeduplicatePoi(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "DeduplicatePoiHandler", w, r)
				}
			}
		}
	})
}

/*
MovePoiAtPositionHandler handles request/response marshaling and validation for

	Patch /beta/admin/poi/move
*/
func MovePoiAtPositionHandler(service MovePoiAtPositionHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("MovePoiAtPositionHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:pois:update")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "MovePoiAtPositionHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := movePoiAtPositionResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/admin/poi/move", w, r),
		}
		request := MovePoiAtPositionRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.MovePoiAtPosition(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "MovePoiAtPositionHandler", w, r)
				}
			}
		}
	})
}

/*
GetAppsHandler handles request/response marshaling and validation for

	Get /beta/apps
*/
func GetAppsHandler(service GetAppsHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetAppsHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:apps:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetAppsHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getAppsResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/apps", w, r),
		}
		request := GetAppsRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPageNumber,
			Location: runtime.ScanInQuery,
			Name:     "page[number]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamPageSize,
			Location: runtime.ScanInQuery,
			Name:     "page[size]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterAppType,
			Location: runtime.ScanInQuery,
			Name:     "filter[appType]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterCache,
			Location: runtime.ScanInQuery,
			Name:     "filter[cache]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterSince,
			Location: runtime.ScanInQuery,
			Name:     "filter[since]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetApps(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetAppsHandler", w, r)
			}
		}
	})
}

/*
CreateAppHandler handles request/response marshaling and validation for

	Post /beta/apps
*/
func CreateAppHandler(service CreateAppHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("CreateAppHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:apps:create")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "CreateAppHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := createAppResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/apps", w, r),
		}
		request := CreateAppRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.CreateApp(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "CreateAppHandler", w, r)
				}
			}
		}
	})
}

/*
CheckForPaceAppHandler handles request/response marshaling and validation for

	Get /beta/apps/query
*/
func CheckForPaceAppHandler(service CheckForPaceAppHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("CheckForPaceAppHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:apps:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "CheckForPaceAppHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := checkForPaceAppResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/apps/query", w, r),
		}
		request := CheckForPaceAppRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamFilterLatitude,
			Location: runtime.ScanInQuery,
			Name:     "filter[latitude]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterLongitude,
			Location: runtime.ScanInQuery,
			Name:     "filter[longitude]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterAppType,
			Location: runtime.ScanInQuery,
			Name:     "filter[appType]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.CheckForPaceApp(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "CheckForPaceAppHandler", w, r)
			}
		}
	})
}

/*
DeleteAppHandler handles request/response marshaling and validation for

	Delete /beta/apps/{appID}
*/
func DeleteAppHandler(service DeleteAppHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("DeleteAppHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:apps:delete")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "DeleteAppHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := deleteAppResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/apps/{appID}", w, r),
		}
		request := DeleteAppRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamAppID,
			Location: runtime.ScanInPath,
			Input:    vars["appID"],
			Name:     "appID",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.DeleteApp(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "DeleteAppHandler", w, r)
			}
		}
	})
}

/*
GetAppHandler handles request/response marshaling and validation for

	Get /beta/apps/{appID}
*/
func GetAppHandler(service GetAppHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetAppHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:apps:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetAppHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getAppResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/apps/{appID}", w, r),
		}
		request := GetAppRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamAppID,
			Location: runtime.ScanInPath,
			Input:    vars["appID"],
			Name:     "appID",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetApp(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetAppHandler", w, r)
			}
		}
	})
}

/*
UpdateAppHandler handles request/response marshaling and validation for

	Put /beta/apps/{appID}
*/
func UpdateAppHandler(service UpdateAppHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("UpdateAppHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:apps:update")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "UpdateAppHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := updateAppResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/apps/{appID}", w, r),
		}
		request := UpdateAppRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamAppID,
			Location: runtime.ScanInPath,
			Input:    vars["appID"],
			Name:     "appID",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.UpdateApp(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "UpdateAppHandler", w, r)
				}
			}
		}
	})
}

/*
GetAppPOIsRelationshipsHandler handles request/response marshaling and validation for

	Get /beta/apps/{appID}/relationships/pois
*/
func GetAppPOIsRelationshipsHandler(service GetAppPOIsRelationshipsHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetAppPOIsRelationshipsHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:apps:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetAppPOIsRelationshipsHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getAppPOIsRelationshipsResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/apps/{appID}/relationships/pois", w, r),
		}
		request := GetAppPOIsRelationshipsRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamAppID,
			Location: runtime.ScanInPath,
			Input:    vars["appID"],
			Name:     "appID",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetAppPOIsRelationships(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetAppPOIsRelationshipsHandler", w, r)
			}
		}
	})
}

/*
UpdateAppPOIsRelationshipsHandler handles request/response marshaling and validation for

	Patch /beta/apps/{appID}/relationships/pois
*/
func UpdateAppPOIsRelationshipsHandler(service UpdateAppPOIsRelationshipsHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("UpdateAppPOIsRelationshipsHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:apps:update")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "UpdateAppPOIsRelationshipsHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := updateAppPOIsRelationshipsResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/apps/{appID}/relationships/pois", w, r),
		}
		request := UpdateAppPOIsRelationshipsRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamAppID,
			Location: runtime.ScanInPath,
			Input:    vars["appID"],
			Name:     "appID",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.UpdateAppPOIsRelationships(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "UpdateAppPOIsRelationshipsHandler", w, r)
				}
			}
		}
	})
}

/*
GetDuplicatesKMLHandler handles request/response marshaling and validation for

	Get /beta/datadumps/duplicatemap/{countryCode}
*/
func GetDuplicatesKMLHandler(service GetDuplicatesKMLHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetDuplicatesKMLHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:dumps:duplicatemap")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetDuplicatesKMLHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getDuplicatesKMLResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/datadumps/duplicatemap/{countryCode}", w, r),
		}
		request := GetDuplicatesKMLRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamCountryCode,
			Location: runtime.ScanInPath,
			Input:    vars["countryCode"],
			Name:     "countryCode",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetDuplicatesKML(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetDuplicatesKMLHandler", w, r)
			}
		}
	})
}

/*
GetPoisDumpHandler handles request/response marshaling and validation for

	Get /beta/datadumps/pois
*/
func GetPoisDumpHandler(service GetPoisDumpHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetPoisDumpHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:dumps:pois")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetPoisDumpHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getPoisDumpResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/datadumps/pois", w, r),
		}
		request := GetPoisDumpRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamAccept,
			Location: runtime.ScanInHeader,
			Name:     "Accept",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetPoisDump(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetPoisDumpHandler", w, r)
			}
		}
	})
}

/*
DeleteGasStationReferenceStatusHandler handles request/response marshaling and validation for

	Delete /beta/delivery/gas-stations/{gasStationId}/reference-status/{reference}
*/
func DeleteGasStationReferenceStatusHandler(service DeleteGasStationReferenceStatusHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("DeleteGasStationReferenceStatusHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:gas-stations.references:update")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "DeleteGasStationReferenceStatusHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := deleteGasStationReferenceStatusResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/delivery/gas-stations/{gasStationId}/reference-status/{reference}", w, r),
		}
		request := DeleteGasStationReferenceStatusRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamGasStationID,
			Location: runtime.ScanInPath,
			Input:    vars["gasStationId"],
			Name:     "gasStationId",
		}, &runtime.ScanParameter{
			Data:     &request.ParamReference,
			Location: runtime.ScanInPath,
			Input:    vars["reference"],
			Name:     "reference",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.DeleteGasStationReferenceStatus(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "DeleteGasStationReferenceStatusHandler", w, r)
			}
		}
	})
}

/*
PutGasStationReferenceStatusHandler handles request/response marshaling and validation for

	Put /beta/delivery/gas-stations/{gasStationId}/reference-status/{reference}
*/
func PutGasStationReferenceStatusHandler(service PutGasStationReferenceStatusHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("PutGasStationReferenceStatusHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:gas-stations.references:update")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "PutGasStationReferenceStatusHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := putGasStationReferenceStatusResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/delivery/gas-stations/{gasStationId}/reference-status/{reference}", w, r),
		}
		request := PutGasStationReferenceStatusRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamGasStationID,
			Location: runtime.ScanInPath,
			Input:    vars["gasStationId"],
			Name:     "gasStationId",
		}, &runtime.ScanParameter{
			Data:     &request.ParamReference,
			Location: runtime.ScanInPath,
			Input:    vars["reference"],
			Name:     "reference",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.PutGasStationReferenceStatus(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "PutGasStationReferenceStatusHandler", w, r)
				}
			}
		}
	})
}

/*
GetEventsHandler handles request/response marshaling and validation for

	Get /beta/events
*/
func GetEventsHandler(service GetEventsHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetEventsHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:events:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetEventsHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getEventsResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/events", w, r),
		}
		request := GetEventsRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPageNumber,
			Location: runtime.ScanInQuery,
			Name:     "page[number]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamPageSize,
			Location: runtime.ScanInQuery,
			Name:     "page[size]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterSourceID,
			Location: runtime.ScanInQuery,
			Name:     "filter[sourceId]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterUserID,
			Location: runtime.ScanInQuery,
			Name:     "filter[userId]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetEvents(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetEventsHandler", w, r)
			}
		}
	})
}

/*
GetGasStationsHandler handles request/response marshaling and validation for

	Get /beta/gas-stations
*/
func GetGasStationsHandler(service GetGasStationsHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetGasStationsHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:gas-stations:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetGasStationsHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getGasStationsResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/gas-stations", w, r),
		}
		request := GetGasStationsRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPageNumber,
			Location: runtime.ScanInQuery,
			Name:     "page[number]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamPageSize,
			Location: runtime.ScanInQuery,
			Name:     "page[size]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterPoiType,
			Location: runtime.ScanInQuery,
			Name:     "filter[poiType]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterAppType,
			Location: runtime.ScanInQuery,
			Name:     "filter[appType]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterLatitude,
			Location: runtime.ScanInQuery,
			Name:     "filter[latitude]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterLongitude,
			Location: runtime.ScanInQuery,
			Name:     "filter[longitude]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterRadius,
			Location: runtime.ScanInQuery,
			Name:     "filter[radius]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterBoundingBox,
			Location: runtime.ScanInQuery,
			Name:     "filter[boundingBox]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamCompileOpeningHours,
			Location: runtime.ScanInQuery,
			Name:     "compile[openingHours]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterSource,
			Location: runtime.ScanInQuery,
			Name:     "filter[source]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetGasStations(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetGasStationsHandler", w, r)
			}
		}
	})
}

/*
GetGasStationHandler handles request/response marshaling and validation for

	Get /beta/gas-stations/{id}
*/
func GetGasStationHandler(service GetGasStationHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetGasStationHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:gas-stations:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetGasStationHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getGasStationResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/gas-stations/{id}", w, r),
		}
		request := GetGasStationRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamID,
			Location: runtime.ScanInPath,
			Input:    vars["id"],
			Name:     "id",
		}, &runtime.ScanParameter{
			Data:     &request.ParamCompileOpeningHours,
			Location: runtime.ScanInQuery,
			Name:     "compile[openingHours]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetGasStation(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetGasStationHandler", w, r)
			}
		}
	})
}

/*
GetPriceHistoryHandler handles request/response marshaling and validation for

	Get /beta/gas-stations/{id}/fuel-price-histories/{fuel_type}
*/
func GetPriceHistoryHandler(service GetPriceHistoryHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetPriceHistoryHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:gas-stations:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetPriceHistoryHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getPriceHistoryResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/gas-stations/{id}/fuel-price-histories/{fuel_type}", w, r),
		}
		request := GetPriceHistoryRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamID,
			Location: runtime.ScanInPath,
			Input:    vars["id"],
			Name:     "id",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFuelType,
			Location: runtime.ScanInPath,
			Input:    vars["fuel_type"],
			Name:     "fuel_type",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterFrom,
			Location: runtime.ScanInQuery,
			Name:     "filter[from]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterTo,
			Location: runtime.ScanInQuery,
			Name:     "filter[to]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterGranularity,
			Location: runtime.ScanInQuery,
			Name:     "filter[granularity]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetPriceHistory(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetPriceHistoryHandler", w, r)
			}
		}
	})
}

/*
GetGasStationFuelTypeNameMappingHandler handles request/response marshaling and validation for

	Get /beta/gas-stations/{id}/fueltype
*/
func GetGasStationFuelTypeNameMappingHandler(service GetGasStationFuelTypeNameMappingHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetGasStationFuelTypeNameMappingHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:gas-stations:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetGasStationFuelTypeNameMappingHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getGasStationFuelTypeNameMappingResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/gas-stations/{id}/fueltype", w, r),
		}
		request := GetGasStationFuelTypeNameMappingRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamID,
			Location: runtime.ScanInPath,
			Input:    vars["id"],
			Name:     "id",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterProductName,
			Location: runtime.ScanInQuery,
			Name:     "filter[productName]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetGasStationFuelTypeNameMapping(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetGasStationFuelTypeNameMappingHandler", w, r)
			}
		}
	})
}

/*
GetMetadataFiltersHandler handles request/response marshaling and validation for

	Get /beta/meta
*/
func GetMetadataFiltersHandler(service GetMetadataFiltersHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetMetadataFiltersHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:gas-stations:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetMetadataFiltersHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getMetadataFiltersResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/meta", w, r),
		}
		request := GetMetadataFiltersRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamLatitude,
			Location: runtime.ScanInQuery,
			Name:     "latitude",
		}, &runtime.ScanParameter{
			Data:     &request.ParamLongitude,
			Location: runtime.ScanInQuery,
			Name:     "longitude",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetMetadataFilters(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetMetadataFiltersHandler", w, r)
			}
		}
	})
}

/*
GetPoisHandler handles request/response marshaling and validation for

	Get /beta/pois
*/
func GetPoisHandler(service GetPoisHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetPoisHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:pois:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetPoisHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getPoisResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/pois", w, r),
		}
		request := GetPoisRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPageNumber,
			Location: runtime.ScanInQuery,
			Name:     "page[number]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamPageSize,
			Location: runtime.ScanInQuery,
			Name:     "page[size]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterPoiType,
			Location: runtime.ScanInQuery,
			Name:     "filter[poiType]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterAppID,
			Location: runtime.ScanInQuery,
			Name:     "filter[appId]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetPois(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetPoisHandler", w, r)
			}
		}
	})
}

/*
GetPoiHandler handles request/response marshaling and validation for

	Get /beta/pois/{poiId}
*/
func GetPoiHandler(service GetPoiHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetPoiHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:pois:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetPoiHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getPoiResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/pois/{poiId}", w, r),
		}
		request := GetPoiRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPoiID,
			Location: runtime.ScanInPath,
			Input:    vars["poiId"],
			Name:     "poiId",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetPoi(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetPoiHandler", w, r)
			}
		}
	})
}

/*
ChangePoiHandler handles request/response marshaling and validation for

	Patch /beta/pois/{poiId}
*/
func ChangePoiHandler(service ChangePoiHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("ChangePoiHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:pois:update")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "ChangePoiHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := changePoiResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/pois/{poiId}", w, r),
		}
		request := ChangePoiRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPoiID,
			Location: runtime.ScanInPath,
			Input:    vars["poiId"],
			Name:     "poiId",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.ChangePoi(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "ChangePoiHandler", w, r)
				}
			}
		}
	})
}

/*
GetPoliciesHandler handles request/response marshaling and validation for

	Get /beta/policies
*/
func GetPoliciesHandler(service GetPoliciesHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetPoliciesHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:policies:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetPoliciesHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getPoliciesResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/policies", w, r),
		}
		request := GetPoliciesRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPageNumber,
			Location: runtime.ScanInQuery,
			Name:     "page[number]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamPageSize,
			Location: runtime.ScanInQuery,
			Name:     "page[size]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterPoiType,
			Location: runtime.ScanInQuery,
			Name:     "filter[poiType]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterCountryID,
			Location: runtime.ScanInQuery,
			Name:     "filter[countryId]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterUserID,
			Location: runtime.ScanInQuery,
			Name:     "filter[userId]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetPolicies(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetPoliciesHandler", w, r)
			}
		}
	})
}

/*
CreatePolicyHandler handles request/response marshaling and validation for

	Post /beta/policies
*/
func CreatePolicyHandler(service CreatePolicyHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("CreatePolicyHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:policies:create")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "CreatePolicyHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := createPolicyResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/policies", w, r),
		}
		request := CreatePolicyRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.CreatePolicy(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "CreatePolicyHandler", w, r)
				}
			}
		}
	})
}

/*
GetPolicyHandler handles request/response marshaling and validation for

	Get /beta/policies/{policyId}
*/
func GetPolicyHandler(service GetPolicyHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetPolicyHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:policies:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetPolicyHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getPolicyResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/policies/{policyId}", w, r),
		}
		request := GetPolicyRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPolicyID,
			Location: runtime.ScanInPath,
			Input:    vars["policyId"],
			Name:     "policyId",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetPolicy(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetPolicyHandler", w, r)
			}
		}
	})
}

/*
GetRegionalPricesHandler handles request/response marshaling and validation for

	Get /beta/prices/regional
*/
func GetRegionalPricesHandler(service GetRegionalPricesHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetRegionalPricesHandler", w, r)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetRegionalPricesHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getRegionalPricesResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/prices/regional", w, r),
		}
		request := GetRegionalPricesRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamFilterLatitude,
			Location: runtime.ScanInQuery,
			Name:     "filter[latitude]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterLongitude,
			Location: runtime.ScanInQuery,
			Name:     "filter[longitude]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetRegionalPrices(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetRegionalPricesHandler", w, r)
			}
		}
	})
}

/*
GetSourcesHandler handles request/response marshaling and validation for

	Get /beta/sources
*/
func GetSourcesHandler(service GetSourcesHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetSourcesHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:sources:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetSourcesHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getSourcesResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/sources", w, r),
		}
		request := GetSourcesRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPageNumber,
			Location: runtime.ScanInQuery,
			Name:     "page[number]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamPageSize,
			Location: runtime.ScanInQuery,
			Name:     "page[size]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterPoiType,
			Location: runtime.ScanInQuery,
			Name:     "filter[poiType]",
		}, &runtime.ScanParameter{
			Data:     &request.ParamFilterName,
			Location: runtime.ScanInQuery,
			Name:     "filter[name]",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetSources(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetSourcesHandler", w, r)
			}
		}
	})
}

/*
CreateSourceHandler handles request/response marshaling and validation for

	Post /beta/sources
*/
func CreateSourceHandler(service CreateSourceHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("CreateSourceHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:sources:create")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "CreateSourceHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := createSourceResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/sources", w, r),
		}
		request := CreateSourceRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.CreateSource(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "CreateSourceHandler", w, r)
				}
			}
		}
	})
}

/*
DeleteSourceHandler handles request/response marshaling and validation for

	Delete /beta/sources/{sourceId}
*/
func DeleteSourceHandler(service DeleteSourceHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("DeleteSourceHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:sources:delete")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "DeleteSourceHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := deleteSourceResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/sources/{sourceId}", w, r),
		}
		request := DeleteSourceRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamSourceID,
			Location: runtime.ScanInPath,
			Input:    vars["sourceId"],
			Name:     "sourceId",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.DeleteSource(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "DeleteSourceHandler", w, r)
			}
		}
	})
}

/*
GetSourceHandler handles request/response marshaling and validation for

	Get /beta/sources/{sourceId}
*/
func GetSourceHandler(service GetSourceHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetSourceHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:sources:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetSourceHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getSourceResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/sources/{sourceId}", w, r),
		}
		request := GetSourceRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamSourceID,
			Location: runtime.ScanInPath,
			Input:    vars["sourceId"],
			Name:     "sourceId",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetSource(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetSourceHandler", w, r)
			}
		}
	})
}

/*
UpdateSourceHandler handles request/response marshaling and validation for

	Put /beta/sources/{sourceId}
*/
func UpdateSourceHandler(service UpdateSourceHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("UpdateSourceHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:sources:update")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "UpdateSourceHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := updateSourceResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/sources/{sourceId}", w, r),
		}
		request := UpdateSourceRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamSourceID,
			Location: runtime.ScanInPath,
			Input:    vars["sourceId"],
			Name:     "sourceId",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.UpdateSource(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "UpdateSourceHandler", w, r)
				}
			}
		}
	})
}

/*
GetSubscriptionsHandler handles request/response marshaling and validation for

	Get /beta/subscriptions
*/
func GetSubscriptionsHandler(service GetSubscriptionsHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetSubscriptionsHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:subscriptions:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetSubscriptionsHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getSubscriptionsResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/subscriptions", w, r),
		}
		request := GetSubscriptionsRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.GetSubscriptions(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "GetSubscriptionsHandler", w, r)
				}
			}
		}
	})
}

/*
DeleteSubscriptionHandler handles request/response marshaling and validation for

	Delete /beta/subscriptions/{id}
*/
func DeleteSubscriptionHandler(service DeleteSubscriptionHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("DeleteSubscriptionHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:subscriptions:delete")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "DeleteSubscriptionHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := deleteSubscriptionResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/subscriptions/{id}", w, r),
		}
		request := DeleteSubscriptionRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters

		// Invoke service that implements the business logic
		err := service.DeleteSubscription(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "DeleteSubscriptionHandler", w, r)
			}
		}
	})
}

/*
StoreSubscriptionHandler handles request/response marshaling and validation for

	Put /beta/subscriptions/{id}
*/
func StoreSubscriptionHandler(service StoreSubscriptionHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("StoreSubscriptionHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:subscriptions:create")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "StoreSubscriptionHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := storeSubscriptionResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/beta/subscriptions/{id}", w, r),
		}
		request := StoreSubscriptionRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.StoreSubscription(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "StoreSubscriptionHandler", w, r)
				}
			}
		}
	})
}

/*
GetTilesHandler handles request/response marshaling and validation for

	Post /v1/tiles/query
*/
func GetTilesHandler(service GetTilesHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetTilesHandler", w, r)

		ctx, ok := authBackend.AuthorizeOAuth2(r, w, "poi:tiles:read")
		if !ok {
			return
		}
		r = r.WithContext(ctx)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetTilesHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getTilesResponseWriter{
			ResponseWriter: metrics.NewMetric("poi", "/v1/tiles/query", w, r),
		}
		request := GetTilesRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters

		// Invoke service that implements the business logic
		err := service.GetTiles(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetTilesHandler", w, r)
			}
		}
	})
}

/*
DeduplicatePoiResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type DeduplicatePoiResponseWriter interface {
	http.ResponseWriter
	OK()
	BadRequest(error)
	NotFound(error)
}
type deduplicatePoiResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *deduplicatePoiResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *deduplicatePoiResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with empty response (HTTP code 204)
func (w *deduplicatePoiResponseWriter) OK() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// DeduplicatePoiRequest ...
type DeduplicatePoiRequest struct {
	Request *http.Request `valid:"-"`
	Content DedupeRequest `valid:"-"`
}

/*
MovePoiAtPositionResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type MovePoiAtPositionResponseWriter interface {
	http.ResponseWriter
	OK()
	BadRequest(error)
	NotFound(error)
}
type movePoiAtPositionResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *movePoiAtPositionResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *movePoiAtPositionResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with empty response (HTTP code 204)
func (w *movePoiAtPositionResponseWriter) OK() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// MovePoiAtPositionRequest ...
type MovePoiAtPositionRequest struct {
	Request *http.Request `valid:"-"`
	Content MoveRequest   `valid:"-"`
}

/*
GetAppsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetAppsResponseWriter interface {
	http.ResponseWriter
	OK(LocationBasedApps)
	BadRequest(error)
}
type getAppsResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getAppsResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getAppsResponseWriter) OK(data LocationBasedApps) {
	runtime.Marshal(w, data, 200)
}

/*
GetAppsRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetAppsRequest struct {
	Request            *http.Request `valid:"-"`
	ParamPageNumber    int64         `valid:"optional"`
	ParamPageSize      int64         `valid:"optional"`
	ParamFilterAppType string        `valid:"optional,in(fueling|)"`
	ParamFilterCache   string        `valid:"optional,in(preload|approaching|)"`
	ParamFilterSince   time.Time     `valid:"optional,iso8601"`
}

/*
CreateAppResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type CreateAppResponseWriter interface {
	http.ResponseWriter
	OK(*LocationBasedApp)
	BadRequest(error)
}
type createAppResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *createAppResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 201)
func (w *createAppResponseWriter) OK(data *LocationBasedApp) {
	runtime.Marshal(w, data, 201)
}

// CreateAppRequest ...
type CreateAppRequest struct {
	Request *http.Request    `valid:"-"`
	Content LocationBasedApp `valid:"-"`
}

/*
CheckForPaceAppResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type CheckForPaceAppResponseWriter interface {
	http.ResponseWriter
	OK(LocationBasedAppsWithRefs)
	BadRequest(error)
}
type checkForPaceAppResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *checkForPaceAppResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *checkForPaceAppResponseWriter) OK(data LocationBasedAppsWithRefs) {
	runtime.Marshal(w, data, 200)
}

/*
CheckForPaceAppRequest is a standard http.Request extended with the
un-marshaled content object
*/
type CheckForPaceAppRequest struct {
	Request              *http.Request `valid:"-"`
	ParamFilterLatitude  float32       `valid:"required"`
	ParamFilterLongitude float32       `valid:"required"`
	ParamFilterAppType   string        `valid:"optional,in(fueling|)"`
}

/*
DeleteAppResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type DeleteAppResponseWriter interface {
	http.ResponseWriter
	OK()
	NotFound(error)
}
type deleteAppResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *deleteAppResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// OK responds with empty response (HTTP code 204)
func (w *deleteAppResponseWriter) OK() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

/*
DeleteAppRequest is a standard http.Request extended with the
un-marshaled content object
*/
type DeleteAppRequest struct {
	Request    *http.Request `valid:"-"`
	ParamAppID string        `valid:"optional,uuid"`
}

/*
GetAppResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetAppResponseWriter interface {
	http.ResponseWriter
	OK(*LocationBasedApp)
	BadRequest(error)
	NotFound(error)
}
type getAppResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *getAppResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getAppResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getAppResponseWriter) OK(data *LocationBasedApp) {
	runtime.Marshal(w, data, 200)
}

/*
GetAppRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetAppRequest struct {
	Request    *http.Request `valid:"-"`
	ParamAppID string        `valid:"optional,uuid"`
}

/*
UpdateAppResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type UpdateAppResponseWriter interface {
	http.ResponseWriter
	OK(*LocationBasedApp)
	BadRequest(error)
	NotFound(error)
}
type updateAppResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *updateAppResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *updateAppResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *updateAppResponseWriter) OK(data *LocationBasedApp) {
	runtime.Marshal(w, data, 200)
}

// UpdateAppRequest ...
type UpdateAppRequest struct {
	Request    *http.Request    `valid:"-"`
	Content    LocationBasedApp `valid:"-"`
	ParamAppID string           `valid:"optional,uuid"`
}

/*
GetAppPOIsRelationshipsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetAppPOIsRelationshipsResponseWriter interface {
	http.ResponseWriter
	OK(AppPOIsRelationships)
	BadRequest(error)
}
type getAppPOIsRelationshipsResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getAppPOIsRelationshipsResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getAppPOIsRelationshipsResponseWriter) OK(data AppPOIsRelationships) {
	runtime.Marshal(w, data, 200)
}

/*
GetAppPOIsRelationshipsRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetAppPOIsRelationshipsRequest struct {
	Request    *http.Request `valid:"-"`
	ParamAppID string        `valid:"optional,uuid"`
}

/*
UpdateAppPOIsRelationshipsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type UpdateAppPOIsRelationshipsResponseWriter interface {
	http.ResponseWriter
	OK(AppPOIsRelationships)
	BadRequest(error)
	NotFound(error)
}
type updateAppPOIsRelationshipsResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *updateAppPOIsRelationshipsResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *updateAppPOIsRelationshipsResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *updateAppPOIsRelationshipsResponseWriter) OK(data AppPOIsRelationships) {
	runtime.Marshal(w, data, 200)
}

// UpdateAppPOIsRelationshipsRequest ...
type UpdateAppPOIsRelationshipsRequest struct {
	Request    *http.Request        `valid:"-"`
	Content    AppPOIsRelationships `valid:"-"`
	ParamAppID string               `valid:"optional,uuid"`
}

/*
GetDuplicatesKMLResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetDuplicatesKMLResponseWriter interface {
	http.ResponseWriter
	OK()
	NotFound(error)
}
type getDuplicatesKMLResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *getDuplicatesKMLResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// OK responds with empty response (HTTP code 200)
func (w *getDuplicatesKMLResponseWriter) OK() {
	w.Header().Set("Content-Type", "application/vnd.google-earth.kml+xml")
	w.WriteHeader(200)
}

/*
GetDuplicatesKMLRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetDuplicatesKMLRequest struct {
	Request          *http.Request `valid:"-"`
	ParamCountryCode string        `valid:"optional"`
}

/*
GetPoisDumpResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetPoisDumpResponseWriter interface {
	http.ResponseWriter
	XLSXPOIReport()
}
type getPoisDumpResponseWriter struct {
	http.ResponseWriter
}

// XLSXPOIReport responds with empty response (HTTP code 200)
func (w *getPoisDumpResponseWriter) XLSXPOIReport() {
	w.Header().Set("Content-Type", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")
	w.WriteHeader(200)
}

/*
GetPoisDumpRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetPoisDumpRequest struct {
	Request     *http.Request `valid:"-"`
	ParamAccept string        `valid:"required,in(application/vnd.openxmlformats-officedocument.spreadsheetml.sheet)"`
}

/*
DeleteGasStationReferenceStatusResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type DeleteGasStationReferenceStatusResponseWriter interface {
	http.ResponseWriter
	NoContent()
	NotFound(error)
}
type deleteGasStationReferenceStatusResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *deleteGasStationReferenceStatusResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// NoContent responds with empty response (HTTP code 204)
func (w *deleteGasStationReferenceStatusResponseWriter) NoContent() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

/*
DeleteGasStationReferenceStatusRequest is a standard http.Request extended with the
un-marshaled content object
*/
type DeleteGasStationReferenceStatusRequest struct {
	Request           *http.Request `valid:"-"`
	ParamGasStationID string        `valid:"required,uuid"`
	ParamReference    string        `valid:"required"`
}

/*
PutGasStationReferenceStatusResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type PutGasStationReferenceStatusResponseWriter interface {
	http.ResponseWriter
	NoContent()
	BadRequest(error)
	NotFound(error)
}
type putGasStationReferenceStatusResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *putGasStationReferenceStatusResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *putGasStationReferenceStatusResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// NoContent responds with empty response (HTTP code 204)
func (w *putGasStationReferenceStatusResponseWriter) NoContent() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// PutGasStationReferenceStatusRequest ...
type PutGasStationReferenceStatusRequest struct {
	Request           *http.Request   `valid:"-"`
	Content           ReferenceStatus `valid:"-"`
	ParamGasStationID string          `valid:"required,uuid"`
	ParamReference    string          `valid:"required"`
}

/*
GetEventsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetEventsResponseWriter interface {
	http.ResponseWriter
	OK(Events)
}
type getEventsResponseWriter struct {
	http.ResponseWriter
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getEventsResponseWriter) OK(data Events) {
	runtime.Marshal(w, data, 200)
}

/*
GetEventsRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetEventsRequest struct {
	Request             *http.Request `valid:"-"`
	ParamPageNumber     int64         `valid:"optional"`
	ParamPageSize       int64         `valid:"optional"`
	ParamFilterSourceID string        `valid:"optional,uuid"`
	ParamFilterUserID   string        `valid:"optional,uuid"`
}

/*
GetGasStationsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetGasStationsResponseWriter interface {
	http.ResponseWriter
	OK(GasStations)
	BadRequest(error)
}
type getGasStationsResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getGasStationsResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getGasStationsResponseWriter) OK(data GasStations) {
	runtime.Marshal(w, data, 200)
}

/*
GetGasStationsRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetGasStationsRequest struct {
	Request                  *http.Request `valid:"-"`
	ParamPageNumber          int64         `valid:"optional"`
	ParamPageSize            int64         `valid:"optional"`
	ParamFilterPoiType       string        `valid:"optional,in(gasStation|)"`
	ParamFilterAppType       []string      `valid:"optional,in(fueling|)"`
	ParamFilterLatitude      float32       `valid:"optional"`
	ParamFilterLongitude     float32       `valid:"optional"`
	ParamFilterRadius        float32       `valid:"optional"`
	ParamFilterBoundingBox   []float32     `valid:"optional"`
	ParamCompileOpeningHours *bool         `valid:"optional,in(true|false|)"`
	ParamFilterSource        string        `valid:"optional,uuid"`
}

/*
GetGasStationResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetGasStationResponseWriter interface {
	http.ResponseWriter
	OK(*GasStation)
	MovedPermanently()
	NotFound(error)
	Expired(error)
}
type getGasStationResponseWriter struct {
	http.ResponseWriter
}

// Expired responds with jsonapi error (HTTP code 410)
func (w *getGasStationResponseWriter) Expired(err error) {
	runtime.WriteError(w, 410, err)
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *getGasStationResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// MovedPermanently responds with empty response (HTTP code 301)
func (w *getGasStationResponseWriter) MovedPermanently() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(301)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getGasStationResponseWriter) OK(data *GasStation) {
	runtime.Marshal(w, data, 200)
}

/*
GetGasStationRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetGasStationRequest struct {
	Request                  *http.Request `valid:"-"`
	ParamID                  string        `valid:"required,uuid"`
	ParamCompileOpeningHours bool          `valid:"optional,in(true|false|)"`
}

/*
GetPriceHistoryResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetPriceHistoryResponseWriter interface {
	http.ResponseWriter
	OK(*PriceHistory)
	BadRequest(error)
	NotFound(error)
}
type getPriceHistoryResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *getPriceHistoryResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getPriceHistoryResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getPriceHistoryResponseWriter) OK(data *PriceHistory) {
	runtime.Marshal(w, data, 200)
}

/*
GetPriceHistoryRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetPriceHistoryRequest struct {
	Request                *http.Request `valid:"-"`
	ParamID                string        `valid:"required,uuid"`
	ParamFuelType          Fuel          `valid:"optional"`
	ParamFilterFrom        time.Time     `valid:"optional,iso8601"`
	ParamFilterTo          time.Time     `valid:"optional,iso8601"`
	ParamFilterGranularity string        `valid:"optional"`
}

/*
GetGasStationFuelTypeNameMappingResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetGasStationFuelTypeNameMappingResponseWriter interface {
	http.ResponseWriter
	OK(*FuelType)
	NotFound(error)
}
type getGasStationFuelTypeNameMappingResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *getGasStationFuelTypeNameMappingResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getGasStationFuelTypeNameMappingResponseWriter) OK(data *FuelType) {
	runtime.Marshal(w, data, 200)
}

/*
GetGasStationFuelTypeNameMappingRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetGasStationFuelTypeNameMappingRequest struct {
	Request                *http.Request `valid:"-"`
	ParamID                string        `valid:"required,uuid"`
	ParamFilterProductName string        `valid:"required"`
}

/*
GetMetadataFiltersResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetMetadataFiltersResponseWriter interface {
	http.ResponseWriter
	OK(Categories)
	BadRequest(error)
}
type getMetadataFiltersResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getMetadataFiltersResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getMetadataFiltersResponseWriter) OK(data Categories) {
	runtime.Marshal(w, data, 200)
}

/*
GetMetadataFiltersRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetMetadataFiltersRequest struct {
	Request        *http.Request `valid:"-"`
	ParamLatitude  float32       `valid:"required"`
	ParamLongitude float32       `valid:"required"`
}

/*
GetPoisResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetPoisResponseWriter interface {
	http.ResponseWriter
	OK(POIs)
	BadRequest(error)
}
type getPoisResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getPoisResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getPoisResponseWriter) OK(data POIs) {
	runtime.Marshal(w, data, 200)
}

/*
GetPoisRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetPoisRequest struct {
	Request            *http.Request `valid:"-"`
	ParamPageNumber    int64         `valid:"optional"`
	ParamPageSize      int64         `valid:"optional"`
	ParamFilterPoiType POIType       `valid:"optional"`
	ParamFilterAppID   string        `valid:"optional,uuid"`
}

/*
GetPoiResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetPoiResponseWriter interface {
	http.ResponseWriter
	OK(*POI)
	MovedPermanently()
	BadRequest(error)
	NotFound(error)
	Expired(error)
}
type getPoiResponseWriter struct {
	http.ResponseWriter
}

// Expired responds with jsonapi error (HTTP code 410)
func (w *getPoiResponseWriter) Expired(err error) {
	runtime.WriteError(w, 410, err)
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *getPoiResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getPoiResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// MovedPermanently responds with empty response (HTTP code 301)
func (w *getPoiResponseWriter) MovedPermanently() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(301)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getPoiResponseWriter) OK(data *POI) {
	runtime.Marshal(w, data, 200)
}

/*
GetPoiRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetPoiRequest struct {
	Request    *http.Request `valid:"-"`
	ParamPoiID string        `valid:"optional,uuid"`
}

/*
ChangePoiResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type ChangePoiResponseWriter interface {
	http.ResponseWriter
	OK(*POI)
	BadRequest(error)
	NotFound(error)
}
type changePoiResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *changePoiResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *changePoiResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *changePoiResponseWriter) OK(data *POI) {
	runtime.Marshal(w, data, 200)
}

// ChangePoiRequest ...
type ChangePoiRequest struct {
	Request    *http.Request `valid:"-"`
	Content    POI           `valid:"-"`
	ParamPoiID string        `valid:"optional,uuid"`
}

/*
GetPoliciesResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetPoliciesResponseWriter interface {
	http.ResponseWriter
	OK(Policies)
	BadRequest(error)
}
type getPoliciesResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getPoliciesResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getPoliciesResponseWriter) OK(data Policies) {
	runtime.Marshal(w, data, 200)
}

/*
GetPoliciesRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetPoliciesRequest struct {
	Request              *http.Request `valid:"-"`
	ParamPageNumber      int64         `valid:"optional"`
	ParamPageSize        int64         `valid:"optional"`
	ParamFilterPoiType   POIType       `valid:"optional"`
	ParamFilterCountryID string        `valid:"optional"`
	ParamFilterUserID    string        `valid:"optional,uuid"`
}

/*
CreatePolicyResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type CreatePolicyResponseWriter interface {
	http.ResponseWriter
	OK(*Policy)
	BadRequest(error)
}
type createPolicyResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *createPolicyResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 201)
func (w *createPolicyResponseWriter) OK(data *Policy) {
	runtime.Marshal(w, data, 201)
}

// CreatePolicyRequest ...
type CreatePolicyRequest struct {
	Request *http.Request `valid:"-"`
	Content Policy        `valid:"-"`
}

/*
GetPolicyResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetPolicyResponseWriter interface {
	http.ResponseWriter
	OK(*Policy)
	BadRequest(error)
	NotFound(error)
}
type getPolicyResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *getPolicyResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getPolicyResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getPolicyResponseWriter) OK(data *Policy) {
	runtime.Marshal(w, data, 200)
}

/*
GetPolicyRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetPolicyRequest struct {
	Request       *http.Request `valid:"-"`
	ParamPolicyID string        `valid:"optional,uuid"`
}

/*
GetRegionalPricesResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetRegionalPricesResponseWriter interface {
	http.ResponseWriter
	OK(RegionalPrices)
	BadRequest(error)
}
type getRegionalPricesResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getRegionalPricesResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getRegionalPricesResponseWriter) OK(data RegionalPrices) {
	runtime.Marshal(w, data, 200)
}

/*
GetRegionalPricesRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetRegionalPricesRequest struct {
	Request              *http.Request `valid:"-"`
	ParamFilterLatitude  float32       `valid:"required"`
	ParamFilterLongitude float32       `valid:"required"`
}

/*
GetSourcesResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetSourcesResponseWriter interface {
	http.ResponseWriter
	OK(Sources)
	BadRequest(error)
}
type getSourcesResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getSourcesResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getSourcesResponseWriter) OK(data Sources) {
	runtime.Marshal(w, data, 200)
}

/*
GetSourcesRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetSourcesRequest struct {
	Request            *http.Request `valid:"-"`
	ParamPageNumber    int64         `valid:"optional"`
	ParamPageSize      int64         `valid:"optional"`
	ParamFilterPoiType POIType       `valid:"optional"`
	ParamFilterName    string        `valid:"optional"`
}

/*
CreateSourceResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type CreateSourceResponseWriter interface {
	http.ResponseWriter
	OK(*Source)
	BadRequest(error)
}
type createSourceResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *createSourceResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 201)
func (w *createSourceResponseWriter) OK(data *Source) {
	runtime.Marshal(w, data, 201)
}

// CreateSourceRequest ...
type CreateSourceRequest struct {
	Request *http.Request `valid:"-"`
	Content Source        `valid:"-"`
}

/*
DeleteSourceResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type DeleteSourceResponseWriter interface {
	http.ResponseWriter
	OK()
	NotFound(error)
}
type deleteSourceResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *deleteSourceResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// OK responds with empty response (HTTP code 204)
func (w *deleteSourceResponseWriter) OK() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

/*
DeleteSourceRequest is a standard http.Request extended with the
un-marshaled content object
*/
type DeleteSourceRequest struct {
	Request       *http.Request `valid:"-"`
	ParamSourceID string        `valid:"optional,uuid"`
}

/*
GetSourceResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetSourceResponseWriter interface {
	http.ResponseWriter
	OK(*Source)
	BadRequest(error)
	NotFound(error)
}
type getSourceResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *getSourceResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getSourceResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getSourceResponseWriter) OK(data *Source) {
	runtime.Marshal(w, data, 200)
}

/*
GetSourceRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetSourceRequest struct {
	Request       *http.Request `valid:"-"`
	ParamSourceID string        `valid:"optional,uuid"`
}

/*
UpdateSourceResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type UpdateSourceResponseWriter interface {
	http.ResponseWriter
	OK(*Source)
	BadRequest(error)
	NotFound(error)
}
type updateSourceResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *updateSourceResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *updateSourceResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *updateSourceResponseWriter) OK(data *Source) {
	runtime.Marshal(w, data, 200)
}

// UpdateSourceRequest ...
type UpdateSourceRequest struct {
	Request       *http.Request `valid:"-"`
	Content       Source        `valid:"-"`
	ParamSourceID string        `valid:"optional,uuid"`
}

/*
GetSubscriptionsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetSubscriptionsResponseWriter interface {
	http.ResponseWriter
	OK(*Subscription)
	BadRequest(error)
}
type getSubscriptionsResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getSubscriptionsResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *getSubscriptionsResponseWriter) OK(data *Subscription) {
	runtime.Marshal(w, data, 200)
}

// GetSubscriptionsContent ...
type GetSubscriptionsContent []*GetSubscriptionsContentItem

// GetSubscriptionsContentItem ...
type GetSubscriptionsContentItem struct {
	ID         string                            `jsonapi:"primary,subscription,omitempty" valid:"uuid,optional"`                   // POI Subscription ID
	Conditions GetSubscriptionsContentConditions `json:"conditions,omitempty" jsonapi:"attr,conditions,omitempty" valid:"optional"` /*
		Optional conditions to reduce the number of notifications to the device. For a notification to be fired, all conditions need to be true.
		The example reads as `fuelPrice < 1.3 && fuelType == "diesel"`. For or conditions use multiple subscriptions.
	*/
	CreatedAt    *time.Time `json:"createdAt,omitempty" jsonapi:"attr,createdAt,omitempty,iso8601" valid:"optional"`    // Time of subscription creation (iso8601 without time zone)
	ExpiresAt    *time.Time `json:"expiresAt,omitempty" jsonapi:"attr,expiresAt,omitempty,iso8601" valid:"optional"`    // Time when the subscription will expire, must not be more then 60 days in the future (iso8601 without time zone)
	ObservedPois []string   `json:"observedPois,omitempty" jsonapi:"attr,observedPois,omitempty" valid:"required,uuid"` // Example: "[prn:pos:gas-stations:4d6dd9db-b0ac-40e8-a099-b606cace6f72 prn:pos:gas-stations:9536bb4a-6623-4b96-9bed-655f30c5b5cf prn:pos:gas-stations:f0fca287-94f7-47f7-8f5a-0fea0dccfaa6]"
	PushToken    string     `json:"pushToken,omitempty" jsonapi:"attr,pushToken,omitempty" valid:"required"`            // PRN describing the push token. E.g. FCM token.
	UpdatedAt    *time.Time `json:"updatedAt,omitempty" jsonapi:"attr,updatedAt,omitempty,iso8601" valid:"optional"`    // Time of LocationBasedApp last update (iso8601 without time zone)
}

// GetSubscriptionsContentConditionsFuelPrice Condition on the fuelPrice of a gas station.
type GetSubscriptionsContentConditionsFuelPrice struct {
	Lt float64 `json:"lt" jsonapi:"attr,lt" valid:"optional"` /*
		Fuel price is less then given amount. Amount is always given in the currency of the gas station. The units are not scaled, for `EUR`, the value 1.3 means 1 euro and 30 cents.
	*/
}

// GetSubscriptionsContentConditionsFuelType Condition on the fuelType of a gas station
type GetSubscriptionsContentConditionsFuelType struct {
	Eq string `json:"eq,omitempty" jsonapi:"attr,eq,omitempty" valid:"optional,in(ron98|ron98e5|ron95e10|diesel|e85|ron91|ron95e5|ron100|dieselGtl|dieselB7|dieselB15|dieselPremium|lpg|cng|lng|h2|truckDiesel|adBlue|truckAdBlue|truckDieselPremium|truckLpg|heatingOil|)"` // Fuel type is equal to given value
}

/*
GetSubscriptionsContentConditions Optional conditions to reduce the number of notifications to the device. For a notification to be fired, all conditions need to be true.
The example reads as `fuelPrice < 1.3 && fuelType == "diesel"`. For or conditions use multiple subscriptions.
*/
type GetSubscriptionsContentConditions struct {
	FuelPrice GetSubscriptionsContentConditionsFuelPrice `json:"fuelPrice,omitempty" jsonapi:"attr,fuelPrice,omitempty" valid:"optional"` // Condition on the fuelPrice of a gas station.
	FuelType  GetSubscriptionsContentConditionsFuelType  `json:"fuelType,omitempty" jsonapi:"attr,fuelType,omitempty" valid:"optional"`   // Condition on the fuelType of a gas station
}

// GetSubscriptionsRequest ...
type GetSubscriptionsRequest struct {
	Request *http.Request           `valid:"-"`
	Content GetSubscriptionsContent `valid:"-"`
}

/*
DeleteSubscriptionResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type DeleteSubscriptionResponseWriter interface {
	http.ResponseWriter
	Deleted()
	NotFound(error)
}
type deleteSubscriptionResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *deleteSubscriptionResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// Deleted responds with empty response (HTTP code 204)
func (w *deleteSubscriptionResponseWriter) Deleted() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

/*
DeleteSubscriptionRequest is a standard http.Request extended with the
un-marshaled content object
*/
type DeleteSubscriptionRequest struct {
	Request *http.Request `valid:"-"`
}

/*
StoreSubscriptionResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type StoreSubscriptionResponseWriter interface {
	http.ResponseWriter
	Stored(*Subscription)
	BadRequest(error)
}
type storeSubscriptionResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *storeSubscriptionResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// Stored responds with jsonapi marshaled data (HTTP code 200)
func (w *storeSubscriptionResponseWriter) Stored(data *Subscription) {
	runtime.Marshal(w, data, 200)
}

// StoreSubscriptionRequest ...
type StoreSubscriptionRequest struct {
	Request *http.Request `valid:"-"`
	Content Subscription  `valid:"-"`
}

/*
GetTilesResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetTilesResponseWriter interface {
	http.ResponseWriter
	OK()
	BadRequest(error)
}
type getTilesResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *getTilesResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// OK responds with empty response (HTTP code 200)
func (w *getTilesResponseWriter) OK() {
	w.Header().Set("Content-Type", "application/protobuf")
	w.WriteHeader(200)
}

// GetTilesRequest ...
type GetTilesRequest struct {
	Request *http.Request `valid:"-"`
}

// Service interface for DeduplicatePoiHandler handler
type DeduplicatePoiHandlerService interface {
	// DeduplicatePoi Specify if a list of POI are considered to be duplicates of a specific POI
	DeduplicatePoi(context.Context, DeduplicatePoiResponseWriter, *DeduplicatePoiRequest) error
}

// Service interface for MovePoiAtPositionHandler handler
type MovePoiAtPositionHandlerService interface {
	// MovePoiAtPosition Allows an admin to move a POI identified by its ID to a specific position
	MovePoiAtPosition(context.Context, MovePoiAtPositionResponseWriter, *MovePoiAtPositionRequest) error
}

// Service interface for GetAppsHandler handler
type GetAppsHandlerService interface {
	/*
	   GetApps Returns a paginated list of apps

	   Returns a paginated list of apps optionally filtered by type and/or query.
	*/
	GetApps(context.Context, GetAppsResponseWriter, *GetAppsRequest) error
}

// Service interface for CreateAppHandler handler
type CreateAppHandlerService interface {
	/*
	   CreateApp Creates a new application

	   Creates a new application
	*/
	CreateApp(context.Context, CreateAppResponseWriter, *CreateAppRequest) error
}

// Service interface for CheckForPaceAppHandler handler
type CheckForPaceAppHandlerService interface {
	/*
	   CheckForPaceApp Query for location-based apps

	   These location-based PACE apps deliver additional services for PACE customers based on their current position.
	   You can (or should) trigger this whenever:
	   * A longer stand-still is detected
	   * The engine is turned off
	   * Every 5 seconds if the user "left the road"

	   Please note that calling this API is very cheap and can be done regularly.
	*/
	CheckForPaceApp(context.Context, CheckForPaceAppResponseWriter, *CheckForPaceAppRequest) error
}

// Service interface for DeleteAppHandler handler
type DeleteAppHandlerService interface {
	/*
	   DeleteApp Deletes App with specified id

	   Deletes App with specified id
	*/
	DeleteApp(context.Context, DeleteAppResponseWriter, *DeleteAppRequest) error
}

// Service interface for GetAppHandler handler
type GetAppHandlerService interface {
	/*
	   GetApp Returns App with specified id

	   Returns App with specified id.
	   In case the query returns a `404` (`Not Found`) the app was deleted and should be deleted from any caches.
	*/
	GetApp(context.Context, GetAppResponseWriter, *GetAppRequest) error
}

// Service interface for UpdateAppHandler handler
type UpdateAppHandlerService interface {
	/*
	   UpdateApp Updates App with specified id

	   Updates App with specified id
	*/
	UpdateApp(context.Context, UpdateAppResponseWriter, *UpdateAppRequest) error
}

// Service interface for GetAppPOIsRelationshipsHandler handler
type GetAppPOIsRelationshipsHandlerService interface {
	/*
	   GetAppPOIsRelationships Returns all POI relations for specified app id

	   Returns all POI relations for specified app id
	*/
	GetAppPOIsRelationships(context.Context, GetAppPOIsRelationshipsResponseWriter, *GetAppPOIsRelationshipsRequest) error
}

// Service interface for UpdateAppPOIsRelationshipsHandler handler
type UpdateAppPOIsRelationshipsHandlerService interface {
	/*
	   UpdateAppPOIsRelationships Update all POI relations for specified app id

	   Update all POI relations for specified app id
	*/
	UpdateAppPOIsRelationships(context.Context, UpdateAppPOIsRelationshipsResponseWriter, *UpdateAppPOIsRelationshipsRequest) error
}

// Service interface for GetDuplicatesKMLHandler handler
type GetDuplicatesKMLHandlerService interface {
	/*
	   GetDuplicatesKML Duplicate Map for country (KML)

	   Generates a map of potential gas station duplicates (closer than 50m to eachother) for specified country.
	*/
	GetDuplicatesKML(context.Context, GetDuplicatesKMLResponseWriter, *GetDuplicatesKMLRequest) error
}

// Service interface for GetPoisDumpHandler handler
type GetPoisDumpHandlerService interface {
	/*
	   GetPoisDump Create a full POI dump

	   Dump all POI data in XLSX format, along with full amenities.
	*/
	GetPoisDump(context.Context, GetPoisDumpResponseWriter, *GetPoisDumpRequest) error
}

// Service interface for DeleteGasStationReferenceStatusHandler handler
type DeleteGasStationReferenceStatusHandlerService interface {
	/*
	   DeleteGasStationReferenceStatus Deletes a reference status of a gas station

	   Deletes a reference status of a gas station
	*/
	DeleteGasStationReferenceStatus(context.Context, DeleteGasStationReferenceStatusResponseWriter, *DeleteGasStationReferenceStatusRequest) error
}

// Service interface for PutGasStationReferenceStatusHandler handler
type PutGasStationReferenceStatusHandlerService interface {
	/*
	   PutGasStationReferenceStatus Creates or updates a reference status of a gas station

	   Creates or updates a reference status of a gas station
	*/
	PutGasStationReferenceStatus(context.Context, PutGasStationReferenceStatusResponseWriter, *PutGasStationReferenceStatusRequest) error
}

// Service interface for GetEventsHandler handler
type GetEventsHandlerService interface {
	/*
	   GetEvents Returns a list of events

	   Returns a list of events optionally filtered by poi type and/or country id and/or user id
	*/
	GetEvents(context.Context, GetEventsResponseWriter, *GetEventsRequest) error
}

// Service interface for GetGasStationsHandler handler
type GetGasStationsHandlerService interface {
	/*
	   GetGasStations Query for gas stations

	   There are two ways to search for gas stations in a geo location. You can use either one, or none, but not both ways.

	   To search inside a specific radius around a given longitude and latitude provide the following query parameters:

	   * latitude
	   * longitude
	   * radius

	   To search inside a bounding box provide the following query parameter:

	   * boundingBox
	*/
	GetGasStations(context.Context, GetGasStationsResponseWriter, *GetGasStationsRequest) error
}

// Service interface for GetGasStationHandler handler
type GetGasStationHandlerService interface {
	/*
	   GetGasStation Get a specific gas station

	   Returns an individual gas station
	*/
	GetGasStation(context.Context, GetGasStationResponseWriter, *GetGasStationRequest) error
}

// Service interface for GetPriceHistoryHandler handler
type GetPriceHistoryHandlerService interface {
	/*
	   GetPriceHistory Get price history for a specific gas station

	   Get the price history for a specific gas station and fuel type on a period of time which can begin no sooner than 37 days ago; the time interval between price changes can be set to minute, hour, day, week, month or year
	*/
	GetPriceHistory(context.Context, GetPriceHistoryResponseWriter, *GetPriceHistoryRequest) error
}

// Service interface for GetGasStationFuelTypeNameMappingHandler handler
type GetGasStationFuelTypeNameMappingHandlerService interface {
	/*
	   GetGasStationFuelTypeNameMapping Get a mapping from gas station specific fuel product name mapped to a normalized fuel type

	   Every gas station potential has different names for the same fuel types. This endpoint accepts the gas station's specific name and return a mapping where the specific name is mapped to a normalized version which should be globally the same across gas stations.
	*/
	GetGasStationFuelTypeNameMapping(context.Context, GetGasStationFuelTypeNameMappingResponseWriter, *GetGasStationFuelTypeNameMappingRequest) error
}

// Service interface for GetMetadataFiltersHandler handler
type GetMetadataFiltersHandlerService interface {
	/*
	   GetMetadataFilters Query for filterable values inside a radius

	   Returns filterable values around the current location on the map, within a certain radius.
	   For the latitude and longitude values used in the request, returns the available and unavailable values for the following fields:

	     - brand

	     - payment methods

	     - amenities
	*/
	GetMetadataFilters(context.Context, GetMetadataFiltersResponseWriter, *GetMetadataFiltersRequest) error
}

// Service interface for GetPoisHandler handler
type GetPoisHandlerService interface {
	/*
	   GetPois Returns a paginated list of POIs

	   Returns a paginated list of POIs optionally filtered by type, appId and/or query
	*/
	GetPois(context.Context, GetPoisResponseWriter, *GetPoisRequest) error
}

// Service interface for GetPoiHandler handler
type GetPoiHandlerService interface {
	/*
	   GetPoi Returns POI with specified id

	   Returns POI with specified id
	*/
	GetPoi(context.Context, GetPoiResponseWriter, *GetPoiRequest) error
}

// Service interface for ChangePoiHandler handler
type ChangePoiHandlerService interface {
	/*
	   ChangePoi Updates POI with specified id (only passed attributes will be updated)

	   Returns POI with specified id (only passed attributes will be updated)
	*/
	ChangePoi(context.Context, ChangePoiResponseWriter, *ChangePoiRequest) error
}

// Service interface for GetPoliciesHandler handler
type GetPoliciesHandlerService interface {
	/*
	   GetPolicies Returns a paginated list of policies

	   Returns a paginated list of policies optionally filtered by poi type and/or country id and/or user id
	*/
	GetPolicies(context.Context, GetPoliciesResponseWriter, *GetPoliciesRequest) error
}

// Service interface for CreatePolicyHandler handler
type CreatePolicyHandlerService interface {
	/*
	   CreatePolicy Creates a new policy

	   Creates a new policy
	*/
	CreatePolicy(context.Context, CreatePolicyResponseWriter, *CreatePolicyRequest) error
}

// Service interface for GetPolicyHandler handler
type GetPolicyHandlerService interface {
	/*
	   GetPolicy Returns policy with specified id

	   Returns policy with specified id
	*/
	GetPolicy(context.Context, GetPolicyResponseWriter, *GetPolicyRequest) error
}

// Service interface for GetRegionalPricesHandler handler
type GetRegionalPricesHandlerService interface {
	/*
	   GetRegionalPrices Search for regional prices in the area

	   Search for regional prices in the area centered at input latitude/longitude. Lower/Upper limits are set for each fuel type returned.
	*/
	GetRegionalPrices(context.Context, GetRegionalPricesResponseWriter, *GetRegionalPricesRequest) error
}

// Service interface for GetSourcesHandler handler
type GetSourcesHandlerService interface {
	/*
	   GetSources Returns a paginated list of sources

	   Returns a paginated list of sources optionally filtered by poi type and/or name
	*/
	GetSources(context.Context, GetSourcesResponseWriter, *GetSourcesRequest) error
}

// Service interface for CreateSourceHandler handler
type CreateSourceHandlerService interface {
	/*
	   CreateSource Creates a new source

	   Creates a new source
	*/
	CreateSource(context.Context, CreateSourceResponseWriter, *CreateSourceRequest) error
}

// Service interface for DeleteSourceHandler handler
type DeleteSourceHandlerService interface {
	/*
	   DeleteSource Deletes source with specified id

	   Deletes source with specified id
	*/
	DeleteSource(context.Context, DeleteSourceResponseWriter, *DeleteSourceRequest) error
}

// Service interface for GetSourceHandler handler
type GetSourceHandlerService interface {
	/*
	   GetSource Returns source with specified id

	   Returns source with specified id
	*/
	GetSource(context.Context, GetSourceResponseWriter, *GetSourceRequest) error
}

// Service interface for UpdateSourceHandler handler
type UpdateSourceHandlerService interface {
	/*
	   UpdateSource Updates source with specified id

	   Updates source with specified id
	*/
	UpdateSource(context.Context, UpdateSourceResponseWriter, *UpdateSourceRequest) error
}

// Service interface for GetSubscriptionsHandler handler
type GetSubscriptionsHandlerService interface {
	/*
	   GetSubscriptions Get the list of POI subscriptions for the user or device

	   Returns a list of all current (not expired) subscriptions of the user.
	*/
	GetSubscriptions(context.Context, GetSubscriptionsResponseWriter, *GetSubscriptionsRequest) error
}

// Service interface for DeleteSubscriptionHandler handler
type DeleteSubscriptionHandlerService interface {
	/*
	   DeleteSubscription Deletes a previously created POI subscription
	*/
	DeleteSubscription(context.Context, DeleteSubscriptionResponseWriter, *DeleteSubscriptionRequest) error
}

// Service interface for StoreSubscriptionHandler handler
type StoreSubscriptionHandlerService interface {
	/*
	   StoreSubscription Stores a POI subscription

	   Stores a POI subscription to send a push notification to the device with the specified `pushToken` once one of the pois change based on the change condition. The notification contains (max 4kb)
	   ```

	   	{
	   	  "target": "..."
	   	  "subscription": "706087b4-8bca-4db9-b037-8a7ff4ce5633",
	   	  "poi": {
	   	    "id": "4d6dd9db-b0ac-40e8-a099-b606cace6f72", # poi ID
	   	    "type": "gasStation",
	   	    "attributes": {
	   	      # ... more data of the type
	   	    }
	   	  }
	   	}

	   ```
	*/
	StoreSubscription(context.Context, StoreSubscriptionResponseWriter, *StoreSubscriptionRequest) error
}

// Service interface for GetTilesHandler handler
type GetTilesHandlerService interface {
	/*
	   GetTiles Query for tiles

	   Get a list of map tiles in the Protobuf binary wire format.
	*/
	GetTiles(context.Context, GetTilesResponseWriter, *GetTilesRequest) error
}

// Legacy Interface.
// Use this if you want to fully implement a service.
type Service interface {
	DeduplicatePoiHandlerService
	MovePoiAtPositionHandlerService
	GetAppsHandlerService
	CreateAppHandlerService
	CheckForPaceAppHandlerService
	DeleteAppHandlerService
	GetAppHandlerService
	UpdateAppHandlerService
	GetAppPOIsRelationshipsHandlerService
	UpdateAppPOIsRelationshipsHandlerService
	GetDuplicatesKMLHandlerService
	GetPoisDumpHandlerService
	DeleteGasStationReferenceStatusHandlerService
	PutGasStationReferenceStatusHandlerService
	GetEventsHandlerService
	GetGasStationsHandlerService
	GetGasStationHandlerService
	GetPriceHistoryHandlerService
	GetGasStationFuelTypeNameMappingHandlerService
	GetMetadataFiltersHandlerService
	GetPoisHandlerService
	GetPoiHandlerService
	ChangePoiHandlerService
	GetPoliciesHandlerService
	CreatePolicyHandlerService
	GetPolicyHandlerService
	GetRegionalPricesHandlerService
	GetSourcesHandlerService
	CreateSourceHandlerService
	DeleteSourceHandlerService
	GetSourceHandlerService
	UpdateSourceHandlerService
	GetSubscriptionsHandlerService
	DeleteSubscriptionHandlerService
	StoreSubscriptionHandlerService
	GetTilesHandlerService
}

// DeleteGasStationReferenceStatusHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func DeleteGasStationReferenceStatusHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(DeleteGasStationReferenceStatusHandlerService); ok {
		return DeleteGasStationReferenceStatusHandler(service, authBackend)
	} else {
		return fallback
	}
}

// PutGasStationReferenceStatusHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func PutGasStationReferenceStatusHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(PutGasStationReferenceStatusHandlerService); ok {
		return PutGasStationReferenceStatusHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetAppPOIsRelationshipsHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetAppPOIsRelationshipsHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetAppPOIsRelationshipsHandlerService); ok {
		return GetAppPOIsRelationshipsHandler(service, authBackend)
	} else {
		return fallback
	}
}

// UpdateAppPOIsRelationshipsHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func UpdateAppPOIsRelationshipsHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(UpdateAppPOIsRelationshipsHandlerService); ok {
		return UpdateAppPOIsRelationshipsHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetPriceHistoryHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetPriceHistoryHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetPriceHistoryHandlerService); ok {
		return GetPriceHistoryHandler(service, authBackend)
	} else {
		return fallback
	}
}

// DeduplicatePoiHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func DeduplicatePoiHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(DeduplicatePoiHandlerService); ok {
		return DeduplicatePoiHandler(service, authBackend)
	} else {
		return fallback
	}
}

// MovePoiAtPositionHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func MovePoiAtPositionHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(MovePoiAtPositionHandlerService); ok {
		return MovePoiAtPositionHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetDuplicatesKMLHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetDuplicatesKMLHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetDuplicatesKMLHandlerService); ok {
		return GetDuplicatesKMLHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetGasStationFuelTypeNameMappingHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetGasStationFuelTypeNameMappingHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetGasStationFuelTypeNameMappingHandlerService); ok {
		return GetGasStationFuelTypeNameMappingHandler(service, authBackend)
	} else {
		return fallback
	}
}

// CheckForPaceAppHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func CheckForPaceAppHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(CheckForPaceAppHandlerService); ok {
		return CheckForPaceAppHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetPoisDumpHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetPoisDumpHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetPoisDumpHandlerService); ok {
		return GetPoisDumpHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetRegionalPricesHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetRegionalPricesHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetRegionalPricesHandlerService); ok {
		return GetRegionalPricesHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetTilesHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetTilesHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetTilesHandlerService); ok {
		return GetTilesHandler(service, authBackend)
	} else {
		return fallback
	}
}

// DeleteAppHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func DeleteAppHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(DeleteAppHandlerService); ok {
		return DeleteAppHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetAppHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetAppHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetAppHandlerService); ok {
		return GetAppHandler(service, authBackend)
	} else {
		return fallback
	}
}

// UpdateAppHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func UpdateAppHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(UpdateAppHandlerService); ok {
		return UpdateAppHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetGasStationHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetGasStationHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetGasStationHandlerService); ok {
		return GetGasStationHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetPoiHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetPoiHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetPoiHandlerService); ok {
		return GetPoiHandler(service, authBackend)
	} else {
		return fallback
	}
}

// ChangePoiHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func ChangePoiHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(ChangePoiHandlerService); ok {
		return ChangePoiHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetPolicyHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetPolicyHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetPolicyHandlerService); ok {
		return GetPolicyHandler(service, authBackend)
	} else {
		return fallback
	}
}

// DeleteSourceHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func DeleteSourceHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(DeleteSourceHandlerService); ok {
		return DeleteSourceHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetSourceHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetSourceHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetSourceHandlerService); ok {
		return GetSourceHandler(service, authBackend)
	} else {
		return fallback
	}
}

// UpdateSourceHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func UpdateSourceHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(UpdateSourceHandlerService); ok {
		return UpdateSourceHandler(service, authBackend)
	} else {
		return fallback
	}
}

// DeleteSubscriptionHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func DeleteSubscriptionHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(DeleteSubscriptionHandlerService); ok {
		return DeleteSubscriptionHandler(service, authBackend)
	} else {
		return fallback
	}
}

// StoreSubscriptionHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func StoreSubscriptionHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(StoreSubscriptionHandlerService); ok {
		return StoreSubscriptionHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetAppsHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetAppsHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetAppsHandlerService); ok {
		return GetAppsHandler(service, authBackend)
	} else {
		return fallback
	}
}

// CreateAppHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func CreateAppHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(CreateAppHandlerService); ok {
		return CreateAppHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetEventsHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetEventsHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetEventsHandlerService); ok {
		return GetEventsHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetGasStationsHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetGasStationsHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetGasStationsHandlerService); ok {
		return GetGasStationsHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetMetadataFiltersHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetMetadataFiltersHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetMetadataFiltersHandlerService); ok {
		return GetMetadataFiltersHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetPoisHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetPoisHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetPoisHandlerService); ok {
		return GetPoisHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetPoliciesHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetPoliciesHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetPoliciesHandlerService); ok {
		return GetPoliciesHandler(service, authBackend)
	} else {
		return fallback
	}
}

// CreatePolicyHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func CreatePolicyHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(CreatePolicyHandlerService); ok {
		return CreatePolicyHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetSourcesHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetSourcesHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetSourcesHandlerService); ok {
		return GetSourcesHandler(service, authBackend)
	} else {
		return fallback
	}
}

// CreateSourceHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func CreateSourceHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(CreateSourceHandlerService); ok {
		return CreateSourceHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetSubscriptionsHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetSubscriptionsHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetSubscriptionsHandlerService); ok {
		return GetSubscriptionsHandler(service, authBackend)
	} else {
		return fallback
	}
}

/*
Router implements: PACE POI API

POI API
*/
func Router(service interface{}, authBackend AuthorizationBackend) *mux.Router {
	router := mux.NewRouter()
	authBackend.InitDeviceID(cfgDeviceID)
	authBackend.InitOAuth2(cfgOAuth2)
	authBackend.InitOIDC(cfgOIDC)
	// Subrouter s1 - Path: /poi
	s1 := router.PathPrefix("/poi").Subrouter()
	s1.Methods("DELETE").Path("/beta/delivery/gas-stations/{gasStationId}/reference-status/{reference}").Name("DeleteGasStationReferenceStatus").Handler(DeleteGasStationReferenceStatusHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("PUT").Path("/beta/delivery/gas-stations/{gasStationId}/reference-status/{reference}").Name("PutGasStationReferenceStatus").Handler(PutGasStationReferenceStatusHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/apps/{appID}/relationships/pois").Name("GetAppPOIsRelationships").Handler(GetAppPOIsRelationshipsHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("PATCH").Path("/beta/apps/{appID}/relationships/pois").Name("UpdateAppPOIsRelationships").Handler(UpdateAppPOIsRelationshipsHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/gas-stations/{id}/fuel-price-histories/{fuel_type}").Name("GetPriceHistory").Handler(GetPriceHistoryHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("PATCH").Path("/beta/admin/poi/dedupe").Name("DeduplicatePoi").Handler(DeduplicatePoiHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("PATCH").Path("/beta/admin/poi/move").Name("MovePoiAtPosition").Handler(MovePoiAtPositionHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/datadumps/duplicatemap/{countryCode}").Name("GetDuplicatesKML").Handler(GetDuplicatesKMLHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/gas-stations/{id}/fueltype").Name("GetGasStationFuelTypeNameMapping").Handler(GetGasStationFuelTypeNameMappingHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/apps/query").Name("CheckForPaceApp").Handler(CheckForPaceAppHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/datadumps/pois").Name("GetPoisDump").Handler(GetPoisDumpHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/prices/regional").Name("GetRegionalPrices").Handler(GetRegionalPricesHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("POST").Path("/v1/tiles/query").Name("GetTiles").Handler(GetTilesHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("DELETE").Path("/beta/apps/{appID}").Name("DeleteApp").Handler(DeleteAppHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/apps/{appID}").Name("GetApp").Handler(GetAppHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("PUT").Path("/beta/apps/{appID}").Name("UpdateApp").Handler(UpdateAppHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/gas-stations/{id}").Name("GetGasStation").Handler(GetGasStationHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/pois/{poiId}").Name("GetPoi").Handler(GetPoiHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("PATCH").Path("/beta/pois/{poiId}").Name("ChangePoi").Handler(ChangePoiHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/policies/{policyId}").Name("GetPolicy").Handler(GetPolicyHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("DELETE").Path("/beta/sources/{sourceId}").Name("DeleteSource").Handler(DeleteSourceHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/sources/{sourceId}").Name("GetSource").Handler(GetSourceHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("PUT").Path("/beta/sources/{sourceId}").Name("UpdateSource").Handler(UpdateSourceHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("DELETE").Path("/beta/subscriptions/{id}").Name("DeleteSubscription").Handler(DeleteSubscriptionHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("PUT").Path("/beta/subscriptions/{id}").Name("StoreSubscription").Handler(StoreSubscriptionHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/apps").Name("GetApps").Handler(GetAppsHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("POST").Path("/beta/apps").Name("CreateApp").Handler(CreateAppHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/events").Name("GetEvents").Handler(GetEventsHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/gas-stations").Name("GetGasStations").Handler(GetGasStationsHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/meta").Name("GetMetadataFilters").Handler(GetMetadataFiltersHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/pois").Name("GetPois").Handler(GetPoisHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/policies").Name("GetPolicies").Handler(GetPoliciesHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("POST").Path("/beta/policies").Name("CreatePolicy").Handler(CreatePolicyHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/sources").Name("GetSources").Handler(GetSourcesHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("POST").Path("/beta/sources").Name("CreateSource").Handler(CreateSourceHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/subscriptions").Name("GetSubscriptions").Handler(GetSubscriptionsHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	return router
}

/*
Router implements: PACE POI API

POI API
*/
func RouterWithFallback(service interface{}, authBackend AuthorizationBackend, fallback http.Handler) *mux.Router {
	router := mux.NewRouter()
	authBackend.InitDeviceID(cfgDeviceID)
	authBackend.InitOAuth2(cfgOAuth2)
	authBackend.InitOIDC(cfgOIDC)
	// Subrouter s1 - Path: /poi
	s1 := router.PathPrefix("/poi").Subrouter()
	s1.Methods("DELETE").Path("/beta/delivery/gas-stations/{gasStationId}/reference-status/{reference}").Name("DeleteGasStationReferenceStatus").Handler(DeleteGasStationReferenceStatusHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("PUT").Path("/beta/delivery/gas-stations/{gasStationId}/reference-status/{reference}").Name("PutGasStationReferenceStatus").Handler(PutGasStationReferenceStatusHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/apps/{appID}/relationships/pois").Name("GetAppPOIsRelationships").Handler(GetAppPOIsRelationshipsHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("PATCH").Path("/beta/apps/{appID}/relationships/pois").Name("UpdateAppPOIsRelationships").Handler(UpdateAppPOIsRelationshipsHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/gas-stations/{id}/fuel-price-histories/{fuel_type}").Name("GetPriceHistory").Handler(GetPriceHistoryHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("PATCH").Path("/beta/admin/poi/dedupe").Name("DeduplicatePoi").Handler(DeduplicatePoiHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("PATCH").Path("/beta/admin/poi/move").Name("MovePoiAtPosition").Handler(MovePoiAtPositionHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/datadumps/duplicatemap/{countryCode}").Name("GetDuplicatesKML").Handler(GetDuplicatesKMLHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/gas-stations/{id}/fueltype").Name("GetGasStationFuelTypeNameMapping").Handler(GetGasStationFuelTypeNameMappingHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/apps/query").Name("CheckForPaceApp").Handler(CheckForPaceAppHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/datadumps/pois").Name("GetPoisDump").Handler(GetPoisDumpHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/prices/regional").Name("GetRegionalPrices").Handler(GetRegionalPricesHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("POST").Path("/v1/tiles/query").Name("GetTiles").Handler(GetTilesHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("DELETE").Path("/beta/apps/{appID}").Name("DeleteApp").Handler(DeleteAppHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/apps/{appID}").Name("GetApp").Handler(GetAppHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("PUT").Path("/beta/apps/{appID}").Name("UpdateApp").Handler(UpdateAppHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/gas-stations/{id}").Name("GetGasStation").Handler(GetGasStationHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/pois/{poiId}").Name("GetPoi").Handler(GetPoiHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("PATCH").Path("/beta/pois/{poiId}").Name("ChangePoi").Handler(ChangePoiHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/policies/{policyId}").Name("GetPolicy").Handler(GetPolicyHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("DELETE").Path("/beta/sources/{sourceId}").Name("DeleteSource").Handler(DeleteSourceHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/sources/{sourceId}").Name("GetSource").Handler(GetSourceHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("PUT").Path("/beta/sources/{sourceId}").Name("UpdateSource").Handler(UpdateSourceHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("DELETE").Path("/beta/subscriptions/{id}").Name("DeleteSubscription").Handler(DeleteSubscriptionHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("PUT").Path("/beta/subscriptions/{id}").Name("StoreSubscription").Handler(StoreSubscriptionHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/apps").Name("GetApps").Handler(GetAppsHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("POST").Path("/beta/apps").Name("CreateApp").Handler(CreateAppHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/events").Name("GetEvents").Handler(GetEventsHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/gas-stations").Name("GetGasStations").Handler(GetGasStationsHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/meta").Name("GetMetadataFilters").Handler(GetMetadataFiltersHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/pois").Name("GetPois").Handler(GetPoisHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/policies").Name("GetPolicies").Handler(GetPoliciesHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("POST").Path("/beta/policies").Name("CreatePolicy").Handler(CreatePolicyHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/sources").Name("GetSources").Handler(GetSourcesHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("POST").Path("/beta/sources").Name("CreateSource").Handler(CreateSourceHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/subscriptions").Name("GetSubscriptions").Handler(GetSubscriptionsHandlerWithFallbackHelper(service, fallback, authBackend))
	return router
}
