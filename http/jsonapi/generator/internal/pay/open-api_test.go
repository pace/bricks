// Code generated by github.com/pace/bricks DO NOT EDIT.
package pay

import (
	"context"
	errors1 "errors"
	sentry "github.com/getsentry/sentry-go"
	mux "github.com/gorilla/mux"
	runtime "github.com/pace/bricks/http/jsonapi/runtime"
	oauth2 "github.com/pace/bricks/http/oauth2"
	oidc "github.com/pace/bricks/http/oidc"
	apikey "github.com/pace/bricks/http/security/apikey"
	errors "github.com/pace/bricks/maintenance/errors"
	metrics "github.com/pace/bricks/maintenance/metric/jsonapi"
	decimal "github.com/shopspring/decimal"
	"net/http"
	"time"
)

// AllPaymentMethodsItem ...
type AllPaymentMethodsItem struct {
	ID                   string `jsonapi:"primary,paymentMethod,omitempty" valid:"uuid,optional"`                                      // Payment method ID
	IdentificationString string `json:"identificationString,omitempty" jsonapi:"attr,identificationString,omitempty" valid:"optional"` // Example: "DE89 **** 3000"
	Kind                 string `json:"kind,omitempty" jsonapi:"attr,kind,omitempty" valid:"optional,in(sepa|)"`                       // Example: "sepa"
}

// AllPaymentMethods ...
type AllPaymentMethods []*AllPaymentMethodsItem

// PaymentMethod ...
type PaymentMethod struct {
	ID     string     `jsonapi:"primary,paymentMethod,omitempty" valid:"optional"`                                // Payment Method ID
	Expiry *time.Time `json:"expiry,omitempty" jsonapi:"attr,expiry,omitempty" valid:"optional,time(2006-01-02)"` // Expiry date
}

// PaymentMethodSEPAAddress ...
type PaymentMethodSEPAAddress struct {
	City        string `json:"city,omitempty" jsonapi:"attr,city,omitempty" valid:"required"`               // Example: "Karlsruhe"
	CountryCode string `json:"countryCode,omitempty" jsonapi:"attr,countryCode,omitempty" valid:"required"` // Country code in as specified in ISO 3166-1.
	HouseNo     string `json:"houseNo,omitempty" jsonapi:"attr,houseNo,omitempty" valid:"required"`         // Example: "18"
	PostalCode  string `json:"postalCode,omitempty" jsonapi:"attr,postalCode,omitempty" valid:"required"`   // Example: "76131"
	Street      string `json:"street,omitempty" jsonapi:"attr,street,omitempty" valid:"required"`           // Example: "Haid-und-Neu-Str."
}

// PaymentMethodSEPA ...
type PaymentMethodSEPA struct {
	ID        string                   `jsonapi:"primary,paymentMethod,omitempty" valid:"uuid,optional"` // The ID of this payment method.
	Address   PaymentMethodSEPAAddress `json:"address,omitempty" jsonapi:"attr,address,omitempty" valid:"required"`
	FirstName string                   `json:"firstName,omitempty" jsonapi:"attr,firstName,omitempty" valid:"required"` // Example: "Jon"
	Iban      string                   `json:"iban,omitempty" jsonapi:"attr,iban,omitempty" valid:"required"`           // Example: "DE89370400440532013000"
	Kind      string                   `json:"kind,omitempty" jsonapi:"attr,kind,omitempty" valid:"required,in(sepa)"`
	LastName  string                   `json:"lastName,omitempty" jsonapi:"attr,lastName,omitempty" valid:"required"` // Example: "Smith"
}

// PaymentMethodsWithPaymentTokensItem ...
type PaymentMethodsWithPaymentTokensItem struct {
	ID                   string          `jsonapi:"primary,paymentMethod,omitempty" valid:"uuid,optional"`                                      // Payment method ID
	IdentificationString string          `json:"identificationString,omitempty" jsonapi:"attr,identificationString,omitempty" valid:"optional"` // Example: "DE89 **** 3000"
	Kind                 string          `json:"kind,omitempty" jsonapi:"attr,kind,omitempty" valid:"optional,in(sepa|)"`                       // Example: "sepa"
	PaymentTokens        []*PaymentToken `json:"paymentTokens,omitempty" jsonapi:"relation,paymentTokens,omitempty" valid:"optional"`
}

// PaymentMethodsWithPaymentTokens ...
type PaymentMethodsWithPaymentTokens []*PaymentMethodsWithPaymentTokensItem

// PaymentToken ...
type PaymentToken struct {
	ID string `jsonapi:"primary,paymentToken,omitempty" valid:"optional"` // Payment Token ID (externally provided - by payment provider)
}

// PaymentTokenCreateApplePayAttributesApplePayHeader ...
type PaymentTokenCreateApplePayAttributesApplePayHeader struct {
	EphemeralPublicKey string `json:"ephemeralPublicKey,omitempty" jsonapi:"attr,ephemeralPublicKey,omitempty" valid:"optional"` // Example: "MFkwEw......."
	PublicKeyHash      string `json:"publicKeyHash,omitempty" jsonapi:"attr,publicKeyHash,omitempty" valid:"optional"`           // Example: "qfj/gQGrF0K6y2EhKDoYUhdi84JEg....."
	TransactionID      string `json:"transactionId,omitempty" jsonapi:"attr,transactionId,omitempty" valid:"optional"`           // Example: "58afcabaa130747ca92eeaff362......"
}

// PaymentTokenCreateApplePayAttributesApplePayPaymentMethod ...
type PaymentTokenCreateApplePayAttributesApplePayPaymentMethod struct {
	DisplayName string `json:"displayName,omitempty" jsonapi:"attr,displayName,omitempty" valid:"optional"` // Example: "Visa 0492"
	Network     string `json:"network,omitempty" jsonapi:"attr,network,omitempty" valid:"optional"`         // Example: "Visa"
	Type        string `json:"type,omitempty" jsonapi:"attr,type,omitempty" valid:"optional"`               // Example: "debit"
}

// PaymentTokenCreateApplePayAttributesApplePay ...
type PaymentTokenCreateApplePayAttributesApplePay struct {
	Data                  string                                                    `json:"data,omitempty" jsonapi:"attr,data,omitempty" valid:"optional"` // Example: "xPE3fXmvym6529AxxQw2PN6czhxoXj2ylfHnJdiRdZktiMdDe2........."
	Header                PaymentTokenCreateApplePayAttributesApplePayHeader        `json:"header,omitempty" jsonapi:"attr,header,omitempty" valid:"optional"`
	PaymentMethod         PaymentTokenCreateApplePayAttributesApplePayPaymentMethod `json:"paymentMethod,omitempty" jsonapi:"attr,paymentMethod,omitempty" valid:"optional"`
	Signature             string                                                    `json:"signature,omitempty" jsonapi:"attr,signature,omitempty" valid:"optional"` // Example: "MIAGCSqGSIb3DQEHAqCAMIACAQExDzANBglghkgBZQMEAgEFADCAB......"
	TransactionIdentifier string                                                    `json:"transactionIdentifier,omitempty" jsonapi:"attr,transactionIdentifier,omitempty" valid:"optional"`
	Version               string                                                    `json:"version,omitempty" jsonapi:"attr,version,omitempty" valid:"optional"` // Example: "EC_v1"
}

// PaymentTokenCreateApplePayAttributes ...
type PaymentTokenCreateApplePayAttributes struct {
	ApplePay PaymentTokenCreateApplePayAttributesApplePay `json:"applePay,omitempty" jsonapi:"attr,applePay,omitempty" valid:"required"`
}

// PaymentTokenCreateApplePay ...
type PaymentTokenCreateApplePay struct {
	Attributes PaymentTokenCreateApplePayAttributes `json:"attributes,omitempty" jsonapi:"attr,attributes,omitempty" valid:"optional"`
}

// TransactionRequestFueling ...
type TransactionRequestFueling struct {
	AppID   string `json:"appId,omitempty" jsonapi:"attr,appId,omitempty" valid:"required,uuid"`   // Location-based App ID
	Mileage int64  `json:"mileage" jsonapi:"attr,mileage" valid:"required"`                        // Current mileage in meters
	PumpID  string `json:"pumpId,omitempty" jsonapi:"attr,pumpId,omitempty" valid:"required,uuid"` // Pump ID
	Vin     string `json:"vin,omitempty" jsonapi:"attr,vin,omitempty" valid:"required"`            // Example: "1B3EL46R36N102271"
}

// TransactionRequest ...
type TransactionRequest struct {
	ID                string                    `jsonapi:"primary,transaction,omitempty" valid:"uuid,optional"` // Transaction ID
	Currency          Currency                  `json:"currency,omitempty" jsonapi:"attr,currency,omitempty" valid:"optional"`
	Fueling           TransactionRequestFueling `json:"fueling,omitempty" jsonapi:"attr,fueling,omitempty" valid:"optional"`
	PaymentToken      string                    `json:"paymentToken,omitempty" jsonapi:"attr,paymentToken,omitempty" valid:"required"`           // Example: "f106ac99-213c-4cf7-8c1b-1e841516026b"
	PriceIncludingVAT *decimal.Decimal          `json:"priceIncludingVAT,omitempty" jsonapi:"attr,priceIncludingVAT,omitempty" valid:"optional"` // Example: "69.34"
}

// Currency ...
type Currency string
type AuthorizationBackend interface {
	AuthorizeOAuth2(r *http.Request, w http.ResponseWriter, scope string) (context.Context, bool)
	InitOAuth2(cfgOAuth2 *oauth2.Config)
	CanAuthorizeOAuth2(r *http.Request) bool
	AuthorizeOpenID(r *http.Request, w http.ResponseWriter, scope string) (context.Context, bool)
	InitOpenID(cfgOpenID *oidc.Config)
	CanAuthorizeOpenID(r *http.Request) bool
	AuthorizeProfileKey(r *http.Request, w http.ResponseWriter) (context.Context, bool)
	InitProfileKey(cfgProfileKey *apikey.Config)
	CanAuthorizeProfileKey(r *http.Request) bool
}

var cfgOAuth2 = &oauth2.Config{
	AuthorizationCode: &oauth2.Flow{
		AuthorizationURL: "https://id.pace.cloud/oauth2/authorize",
		RefreshURL:       "https://id.pace.cloud/oauth2/token",
		Scopes:           map[string]string{"id:sessions:create": "Create a new browser session"},
		TokenURL:         "https://id.pace.cloud/oauth2/token",
	},
	Description: "",
}
var cfgOpenID = &oidc.Config{
	Description:      "",
	OpenIDConnectURL: "https://example.com/.well-known/openid-configuration",
}
var cfgProfileKey = &apikey.Config{
	Description: "prefix with \"Bearer \"",
	In:          "header",
	Name:        "Authorization",
}

/*
GetPaymentMethodsHandler handles request/response marshaling and validation for

	Get /beta/payment-methods
*/
func GetPaymentMethodsHandler(service GetPaymentMethodsHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetPaymentMethodsHandler", w, r)

		// Trace the service function handler execution
		span := sentry.StartSpan(r.Context(), "http.server", sentry.WithDescription("GetPaymentMethodsHandler"))
		defer span.Finish()

		ctx := span.Context()
		r = r.WithContext(ctx)

		// Setup context, response writer and request type
		writer := getPaymentMethodsResponseWriter{
			ResponseWriter: metrics.NewMetric("pay", "/beta/payment-methods", w, r),
		}
		request := GetPaymentMethodsRequest{
			Request: r,
		}

		// Scan and validate incoming request parameters

		// Invoke service that implements the business logic
		err := service.GetPaymentMethods(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetPaymentMethodsHandler", w, r)
			}
		}
	})
}

/*
CreatePaymentMethodSEPAHandler handles request/response marshaling and validation for

	Post /beta/payment-methods/sepa-direct-debit
*/
func CreatePaymentMethodSEPAHandler(service CreatePaymentMethodSEPAHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("CreatePaymentMethodSEPAHandler", w, r)

		// Trace the service function handler execution
		span := sentry.StartSpan(r.Context(), "http.server", sentry.WithDescription("CreatePaymentMethodSEPAHandler"))
		defer span.Finish()

		ctx := span.Context()
		r = r.WithContext(ctx)

		var ok bool
		if authBackend.CanAuthorizeOAuth2(r) {

			ctx, ok = authBackend.AuthorizeOAuth2(r, w, "")
			if !ok {
				return
			}
		} else if authBackend.CanAuthorizeOpenID(r) {

			ctx, ok = authBackend.AuthorizeOpenID(r, w, "")
			if !ok {
				return
			}
		} else if authBackend.CanAuthorizeProfileKey(r) {

			ctx, ok = authBackend.AuthorizeProfileKey(r, w)
			if !ok {
				return
			}
		} else {
			http.Error(w, "Authorization Error", http.StatusUnauthorized)
			return
		}

		// Setup context, response writer and request type
		writer := createPaymentMethodSEPAResponseWriter{
			ResponseWriter: metrics.NewMetric("pay", "/beta/payment-methods/sepa-direct-debit", w, r),
		}
		request := CreatePaymentMethodSEPARequest{
			Request: r,
		}

		// Scan and validate incoming request parameters
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.CreatePaymentMethodSEPA(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "CreatePaymentMethodSEPAHandler", w, r)
				}
			}
		}
	})
}

/*
DeletePaymentMethodHandler handles request/response marshaling and validation for

	Delete /beta/payment-methods/{paymentMethodId}
*/
func DeletePaymentMethodHandler(service DeletePaymentMethodHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("DeletePaymentMethodHandler", w, r)

		// Trace the service function handler execution
		span := sentry.StartSpan(r.Context(), "http.server", sentry.WithDescription("DeletePaymentMethodHandler"))
		defer span.Finish()

		ctx := span.Context()
		r = r.WithContext(ctx)

		var ok bool
		if authBackend.CanAuthorizeOAuth2(r) {

			ctx, ok = authBackend.AuthorizeOAuth2(r, w, "id:sessions:create")
			if !ok {
				return
			}
		} else if authBackend.CanAuthorizeProfileKey(r) {

			ctx, ok = authBackend.AuthorizeProfileKey(r, w)
			if !ok {
				return
			}
		} else {
			http.Error(w, "Authorization Error", http.StatusUnauthorized)
			return
		}

		// Setup context, response writer and request type
		writer := deletePaymentMethodResponseWriter{
			ResponseWriter: metrics.NewMetric("pay", "/beta/payment-methods/{paymentMethodId}", w, r),
		}
		request := DeletePaymentMethodRequest{
			Request: r,
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPaymentMethodID,
			Location: runtime.ScanInPath,
			Input:    vars["paymentMethodId"],
			Name:     "paymentMethodId",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.DeletePaymentMethod(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "DeletePaymentMethodHandler", w, r)
			}
		}
	})
}

/*
AuthorizePaymentMethodHandler handles request/response marshaling and validation for

	Post /beta/payment-methods/{paymentMethodId}/authorize
*/
func AuthorizePaymentMethodHandler(service AuthorizePaymentMethodHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("AuthorizePaymentMethodHandler", w, r)

		// Trace the service function handler execution
		span := sentry.StartSpan(r.Context(), "http.server", sentry.WithDescription("AuthorizePaymentMethodHandler"))
		defer span.Finish()

		ctx := span.Context()
		r = r.WithContext(ctx)

		// Setup context, response writer and request type
		writer := authorizePaymentMethodResponseWriter{
			ResponseWriter: metrics.NewMetric("pay", "/beta/payment-methods/{paymentMethodId}/authorize", w, r),
		}
		request := AuthorizePaymentMethodRequest{
			Request: r,
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPaymentMethodID,
			Location: runtime.ScanInPath,
			Input:    vars["paymentMethodId"],
			Name:     "paymentMethodId",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.AuthorizePaymentMethod(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "AuthorizePaymentMethodHandler", w, r)
				}
			}
		}
	})
}

/*
DeletePaymentTokenHandler handles request/response marshaling and validation for

	Delete /beta/payment-methods/{paymentMethodId}/paymentTokens/{paymentTokenId}
*/
func DeletePaymentTokenHandler(service DeletePaymentTokenHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("DeletePaymentTokenHandler", w, r)

		// Trace the service function handler execution
		span := sentry.StartSpan(r.Context(), "http.server", sentry.WithDescription("DeletePaymentTokenHandler"))
		defer span.Finish()

		ctx := span.Context()
		r = r.WithContext(ctx)

		// Setup context, response writer and request type
		writer := deletePaymentTokenResponseWriter{
			ResponseWriter: metrics.NewMetric("pay", "/beta/payment-methods/{paymentMethodId}/paymentTokens/{paymentTokenId}", w, r),
		}
		request := DeletePaymentTokenRequest{
			Request: r,
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPaymentTokenID,
			Location: runtime.ScanInPath,
			Input:    vars["paymentTokenId"],
			Name:     "paymentTokenId",
		}, &runtime.ScanParameter{
			Data:     &request.ParamPaymentMethodID,
			Location: runtime.ScanInPath,
			Input:    vars["paymentMethodId"],
			Name:     "paymentMethodId",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.DeletePaymentToken(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "DeletePaymentTokenHandler", w, r)
			}
		}
	})
}

/*
GetPaymentMethodsIncludingCreditCheckHandler handles request/response marshaling and validation for

	Get /beta/payment-methods?include=creditCheck
*/
func GetPaymentMethodsIncludingCreditCheckHandler(service GetPaymentMethodsIncludingCreditCheckHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetPaymentMethodsIncludingCreditCheckHandler", w, r)

		// Trace the service function handler execution
		span := sentry.StartSpan(r.Context(), "http.server", sentry.WithDescription("GetPaymentMethodsIncludingCreditCheckHandler"))
		defer span.Finish()

		ctx := span.Context()
		r = r.WithContext(ctx)

		// Setup context, response writer and request type
		writer := getPaymentMethodsIncludingCreditCheckResponseWriter{
			ResponseWriter: metrics.NewMetric("pay", "/beta/payment-methods?include=creditCheck", w, r),
		}
		request := GetPaymentMethodsIncludingCreditCheckRequest{
			Request: r,
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamInclude,
			Location: runtime.ScanInQuery,
			Name:     "include",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetPaymentMethodsIncludingCreditCheck(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetPaymentMethodsIncludingCreditCheckHandler", w, r)
			}
		}
	})
}

/*
GetPaymentMethodsIncludingPaymentTokenHandler handles request/response marshaling and validation for

	Get /beta/payment-methods?include=paymentToken
*/
func GetPaymentMethodsIncludingPaymentTokenHandler(service GetPaymentMethodsIncludingPaymentTokenHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetPaymentMethodsIncludingPaymentTokenHandler", w, r)

		// Trace the service function handler execution
		span := sentry.StartSpan(r.Context(), "http.server", sentry.WithDescription("GetPaymentMethodsIncludingPaymentTokenHandler"))
		defer span.Finish()

		ctx := span.Context()
		r = r.WithContext(ctx)

		// Setup context, response writer and request type
		writer := getPaymentMethodsIncludingPaymentTokenResponseWriter{
			ResponseWriter: metrics.NewMetric("pay", "/beta/payment-methods?include=paymentToken", w, r),
		}
		request := GetPaymentMethodsIncludingPaymentTokenRequest{
			Request: r,
		}

		// Scan and validate incoming request parameters
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamInclude,
			Location: runtime.ScanInQuery,
			Name:     "include",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetPaymentMethodsIncludingPaymentToken(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetPaymentMethodsIncludingPaymentTokenHandler", w, r)
			}
		}
	})
}

/*
ProcessPaymentHandler handles request/response marshaling and validation for

	Post /beta/transaction/{pathDecimal}
*/
func ProcessPaymentHandler(service ProcessPaymentHandlerService, authBackend AuthorizationBackend) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("ProcessPaymentHandler", w, r)

		// Trace the service function handler execution
		span := sentry.StartSpan(r.Context(), "http.server", sentry.WithDescription("ProcessPaymentHandler"))
		defer span.Finish()

		ctx := span.Context()
		r = r.WithContext(ctx)

		// Setup context, response writer and request type
		writer := processPaymentResponseWriter{
			ResponseWriter: metrics.NewMetric("pay", "/beta/transaction/{pathDecimal}", w, r),
		}
		request := ProcessPaymentRequest{
			Request: r,
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamPathDecimal,
			Location: runtime.ScanInPath,
			Input:    vars["pathDecimal"],
			Name:     "pathDecimal",
		}, &runtime.ScanParameter{
			Data:     &request.ParamQueryDecimal,
			Location: runtime.ScanInQuery,
			Name:     "queryDecimal",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.ProcessPayment(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "ProcessPaymentHandler", w, r)
				}
			}
		}
	})
}

/*
GetPaymentMethodsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetPaymentMethodsResponseWriter interface {
	http.ResponseWriter
	AllThePaymentMethodsForUser(AllPaymentMethods)
}
type getPaymentMethodsResponseWriter struct {
	http.ResponseWriter
}

// AllThePaymentMethodsForUser responds with jsonapi marshaled data (HTTP code 200)
func (w *getPaymentMethodsResponseWriter) AllThePaymentMethodsForUser(data AllPaymentMethods) {
	runtime.Marshal(w, data, 200)
}

/*
GetPaymentMethodsRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetPaymentMethodsRequest struct {
	Request *http.Request `valid:"-"`
}

// CreatePaymentMethodSEPACreated ...
type CreatePaymentMethodSEPACreated struct {
	ID                   string `jsonapi:"primary,paymentMethod,omitempty" valid:"uuid,optional"`                                      // Payment method ID
	IdentificationString string `json:"identificationString,omitempty" jsonapi:"attr,identificationString,omitempty" valid:"optional"` // Example: "DE89 **** 3000"
	Kind                 string `json:"kind,omitempty" jsonapi:"attr,kind,omitempty" valid:"optional,in(sepa|)"`
}

/*
CreatePaymentMethodSEPAResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type CreatePaymentMethodSEPAResponseWriter interface {
	http.ResponseWriter
	Created(*CreatePaymentMethodSEPACreated)
	BadRequest(error)
}
type createPaymentMethodSEPAResponseWriter struct {
	http.ResponseWriter
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *createPaymentMethodSEPAResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// Created responds with jsonapi marshaled data (HTTP code 201)
func (w *createPaymentMethodSEPAResponseWriter) Created(data *CreatePaymentMethodSEPACreated) {
	runtime.Marshal(w, data, 201)
}

// CreatePaymentMethodSEPARequest ...
type CreatePaymentMethodSEPARequest struct {
	Request *http.Request     `valid:"-"`
	Content PaymentMethodSEPA `valid:"-"`
}

/*
DeletePaymentMethodResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type DeletePaymentMethodResponseWriter interface {
	http.ResponseWriter
	ThePaymentMethodWasDeletedSuccessfully()
	NotFound(error)
}
type deletePaymentMethodResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *deletePaymentMethodResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// ThePaymentMethodWasDeletedSuccessfully responds with empty response (HTTP code 204)
func (w *deletePaymentMethodResponseWriter) ThePaymentMethodWasDeletedSuccessfully() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

/*
DeletePaymentMethodRequest is a standard http.Request extended with the
un-marshaled content object
*/
type DeletePaymentMethodRequest struct {
	Request              *http.Request `valid:"-"`
	ParamPaymentMethodID string        `valid:"required,uuid"`
}

// AuthorizePaymentMethodOK ...
type AuthorizePaymentMethodOK struct {
	ID       string  `jsonapi:"primary,paymentToken,omitempty" valid:"uuid,optional"`               // paymentToken ID (NOT the token value)
	Amount   float64 `json:"amount" jsonapi:"attr,amount" valid:"optional"`                         // Example: "65.49"
	Currency string  `json:"currency,omitempty" jsonapi:"attr,currency,omitempty" valid:"optional"` // Currency as specified in ISO-4217.
	Value    string  `json:"value,omitempty" jsonapi:"attr,value,omitempty" valid:"optional"`       // The actual token value. Note that the format is subject to change. Treat transparently.
}

/*
AuthorizePaymentMethodResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type AuthorizePaymentMethodResponseWriter interface {
	http.ResponseWriter
	OK(*AuthorizePaymentMethodOK)
	AmountCannotBeAuthorized(error)
	PaymentMethodIsUnknown(error)
	BadGateway(error)
}
type authorizePaymentMethodResponseWriter struct {
	http.ResponseWriter
}

// BadGateway responds with jsonapi error (HTTP code 502)
func (w *authorizePaymentMethodResponseWriter) BadGateway(err error) {
	runtime.WriteError(w, 502, err)
}

// PaymentMethodIsUnknown responds with jsonapi error (HTTP code 404)
func (w *authorizePaymentMethodResponseWriter) PaymentMethodIsUnknown(err error) {
	runtime.WriteError(w, 404, err)
}

// AmountCannotBeAuthorized responds with jsonapi error (HTTP code 403)
func (w *authorizePaymentMethodResponseWriter) AmountCannotBeAuthorized(err error) {
	runtime.WriteError(w, 403, err)
}

// OK responds with jsonapi marshaled data (HTTP code 200)
func (w *authorizePaymentMethodResponseWriter) OK(data *AuthorizePaymentMethodOK) {
	runtime.Marshal(w, data, 200)
}

// AuthorizePaymentMethodContent ...
type AuthorizePaymentMethodContent struct {
	ID       string  `jsonapi:"primary,paymentToken,omitempty" valid:"uuid,optional"`               // ID of the new paymentToken.
	Amount   float64 `json:"amount" jsonapi:"attr,amount" valid:"required"`                         // Example: "65.49"
	Currency string  `json:"currency,omitempty" jsonapi:"attr,currency,omitempty" valid:"required"` // Currency as specified in ISO-4217.
}

// AuthorizePaymentMethodRequest ...
type AuthorizePaymentMethodRequest struct {
	Request              *http.Request                 `valid:"-"`
	Content              AuthorizePaymentMethodContent `valid:"-"`
	ParamPaymentMethodID string                        `valid:"required,uuid"`
}

/*
DeletePaymentTokenResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type DeletePaymentTokenResponseWriter interface {
	http.ResponseWriter
	ThePaymentTokenWasRemovedSuccessfully()
	NotFound(error)
}
type deletePaymentTokenResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *deletePaymentTokenResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// ThePaymentTokenWasRemovedSuccessfully responds with empty response (HTTP code 204)
func (w *deletePaymentTokenResponseWriter) ThePaymentTokenWasRemovedSuccessfully() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

/*
DeletePaymentTokenRequest is a standard http.Request extended with the
un-marshaled content object
*/
type DeletePaymentTokenRequest struct {
	Request              *http.Request `valid:"-"`
	ParamPaymentTokenID  string        `valid:"required"`
	ParamPaymentMethodID string        `valid:"required,uuid"`
}

/*
GetPaymentMethodsIncludingCreditCheckResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetPaymentMethodsIncludingCreditCheckResponseWriter interface {
	http.ResponseWriter
	AllThePaymentMethodsThatCouldBeUsed(AllPaymentMethods)
}
type getPaymentMethodsIncludingCreditCheckResponseWriter struct {
	http.ResponseWriter
}

// AllThePaymentMethodsThatCouldBeUsed responds with jsonapi marshaled data (HTTP code 200)
func (w *getPaymentMethodsIncludingCreditCheckResponseWriter) AllThePaymentMethodsThatCouldBeUsed(data AllPaymentMethods) {
	runtime.Marshal(w, data, 200)
}

/*
GetPaymentMethodsIncludingCreditCheckRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetPaymentMethodsIncludingCreditCheckRequest struct {
	Request      *http.Request `valid:"-"`
	ParamInclude string        `valid:"required,in(creditCheck)"`
}

/*
GetPaymentMethodsIncludingPaymentTokenResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetPaymentMethodsIncludingPaymentTokenResponseWriter interface {
	http.ResponseWriter
	AllThePaymentMethodsWithPreAuthorisedAmounts(PaymentMethodsWithPaymentTokens)
}
type getPaymentMethodsIncludingPaymentTokenResponseWriter struct {
	http.ResponseWriter
}

// AllThePaymentMethodsWithPreAuthorisedAmounts responds with jsonapi marshaled data (HTTP code 200)
func (w *getPaymentMethodsIncludingPaymentTokenResponseWriter) AllThePaymentMethodsWithPreAuthorisedAmounts(data PaymentMethodsWithPaymentTokens) {
	runtime.Marshal(w, data, 200)
}

/*
GetPaymentMethodsIncludingPaymentTokenRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetPaymentMethodsIncludingPaymentTokenRequest struct {
	Request      *http.Request `valid:"-"`
	ParamInclude string        `valid:"required,in(paymentToken)"`
}

// ProcessPaymentCreated ...
type ProcessPaymentCreated struct {
	ID                string                       `jsonapi:"primary,transaction,omitempty" valid:"uuid,optional"` // Transaction ID
	VAT               ProcessPaymentCreatedVAT     `json:"VAT,omitempty" jsonapi:"attr,VAT,omitempty" valid:"optional"`
	Currency          Currency                     `json:"currency,omitempty" jsonapi:"attr,currency,omitempty" valid:"optional"`
	Fueling           ProcessPaymentCreatedFueling `json:"fueling,omitempty" jsonapi:"attr,fueling,omitempty" valid:"optional"`
	PaymentToken      string                       `json:"paymentToken,omitempty" jsonapi:"attr,paymentToken,omitempty" valid:"optional"`           // Example: "f106ac99-213c-4cf7-8c1b-1e841516026b"
	PriceIncludingVAT *decimal.Decimal             `json:"priceIncludingVAT,omitempty" jsonapi:"attr,priceIncludingVAT,omitempty" valid:"optional"` // Example: "69.34"
	PriceWithoutVAT   *decimal.Decimal             `json:"priceWithoutVAT,omitempty" jsonapi:"attr,priceWithoutVAT,omitempty" valid:"optional"`     // Example: "58.27"
}

// ProcessPaymentCreatedVAT ...
type ProcessPaymentCreatedVAT struct {
	Amount *decimal.Decimal `json:"amount,omitempty" jsonapi:"attr,amount,omitempty" valid:"optional"` // Example: "11.07"
	Rate   *decimal.Decimal `json:"rate,omitempty" jsonapi:"attr,rate,omitempty" valid:"optional"`     // Example: "0.19"
}

// ProcessPaymentCreatedFueling ...
type ProcessPaymentCreatedFueling struct {
	AppID   string `json:"appId,omitempty" jsonapi:"attr,appId,omitempty" valid:"required,uuid"`   // Example: "c30bce97-b732-4390-af38-1ac6b017aa4c"
	Mileage int64  `json:"mileage" jsonapi:"attr,mileage" valid:"required"`                        // Example: "66435"
	PumpID  string `json:"pumpId,omitempty" jsonapi:"attr,pumpId,omitempty" valid:"required,uuid"` // Example: "460ffaad-a3c1-4199-b69e-63949ccda82f"
	Vin     string `json:"vin,omitempty" jsonapi:"attr,vin,omitempty" valid:"required"`            // Example: "1B3EL46R36N102271"
}

/*
ProcessPaymentResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type ProcessPaymentResponseWriter interface {
	http.ResponseWriter
	Created(*ProcessPaymentCreated)
	BadRequest(error)
	NotFound(error)
	Conflict(error)
}
type processPaymentResponseWriter struct {
	http.ResponseWriter
}

// Conflict responds with jsonapi error (HTTP code 409)
func (w *processPaymentResponseWriter) Conflict(err error) {
	runtime.WriteError(w, 409, err)
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *processPaymentResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// BadRequest responds with jsonapi error (HTTP code 400)
func (w *processPaymentResponseWriter) BadRequest(err error) {
	runtime.WriteError(w, 400, err)
}

// Created responds with jsonapi marshaled data (HTTP code 201)
func (w *processPaymentResponseWriter) Created(data *ProcessPaymentCreated) {
	runtime.Marshal(w, data, 201)
}

// ProcessPaymentRequest ...
type ProcessPaymentRequest struct {
	Request           *http.Request      `valid:"-"`
	Content           TransactionRequest `valid:"-"`
	ParamPathDecimal  decimal.Decimal    `valid:"required,matches(^(\d*\.)?\d+$)"`
	ParamQueryDecimal decimal.Decimal    `valid:"required,matches(^(\d*\.)?\d+$)"`
}

// Service interface for GetPaymentMethodsHandler handler
type GetPaymentMethodsHandlerService interface {
	// GetPaymentMethods Get all payment methods for user
	GetPaymentMethods(context.Context, GetPaymentMethodsResponseWriter, *GetPaymentMethodsRequest) error
}

// Service interface for CreatePaymentMethodSEPAHandler handler
type CreatePaymentMethodSEPAHandlerService interface {
	/*
	   CreatePaymentMethodSEPA Register SEPA direct debit as a payment method

	   By registering you allow the user to use SEPA direct debit as a payment method.
	   The payment method ID is optional when posting data.
	*/
	CreatePaymentMethodSEPA(context.Context, CreatePaymentMethodSEPAResponseWriter, *CreatePaymentMethodSEPARequest) error
}

// Service interface for DeletePaymentMethodHandler handler
type DeletePaymentMethodHandlerService interface {
	// DeletePaymentMethod Delete a payment method
	DeletePaymentMethod(context.Context, DeletePaymentMethodResponseWriter, *DeletePaymentMethodRequest) error
}

// Service interface for AuthorizePaymentMethodHandler handler
type AuthorizePaymentMethodHandlerService interface {
	/*
	   AuthorizePaymentMethod Authorize a payment using the payment method whose ID is paymentMethodId

	   When successful, returns a paymentToken value.
	*/
	AuthorizePaymentMethod(context.Context, AuthorizePaymentMethodResponseWriter, *AuthorizePaymentMethodRequest) error
}

// Service interface for DeletePaymentTokenHandler handler
type DeletePaymentTokenHandlerService interface {
	// DeletePaymentToken Delete the paymentToken record.
	DeletePaymentToken(context.Context, DeletePaymentTokenResponseWriter, *DeletePaymentTokenRequest) error
}

// Service interface for GetPaymentMethodsIncludingCreditCheckHandler handler
type GetPaymentMethodsIncludingCreditCheckHandlerService interface {
	/*
	   GetPaymentMethodsIncludingCreditCheck Get all ready-to-use payment methods for user

	   This request will return a list of supported payment methods for the current user that they can, in theory, use. That is, ones that are valid and can immediately be used.</br></br>
	   This is as opposed to the regular `/payment-methods`, which does not categorize payment methods as valid for use.</br></br>
	   You should trigger this when the user is approaching on a gas station with fueling support to get a list of available payment methods.</br></br>
	   If the list is empty, you can ask the user to add a payment method to use PACE fueling.
	*/
	GetPaymentMethodsIncludingCreditCheck(context.Context, GetPaymentMethodsIncludingCreditCheckResponseWriter, *GetPaymentMethodsIncludingCreditCheckRequest) error
}

// Service interface for GetPaymentMethodsIncludingPaymentTokenHandler handler
type GetPaymentMethodsIncludingPaymentTokenHandlerService interface {
	/*
	   GetPaymentMethodsIncludingPaymentToken Get all payment methods with pre-authorized amounts

	   This request returns all payment methods with pre-authorized amounts.</br></br>
	   The list will contain the pre-authorized amount (incl. currency), all information about the payment method and the paymentToken that can be used to complete the payment.</br></br>
	   Empty list if there are no pre-authorized amounts.
	*/
	GetPaymentMethodsIncludingPaymentToken(context.Context, GetPaymentMethodsIncludingPaymentTokenResponseWriter, *GetPaymentMethodsIncludingPaymentTokenRequest) error
}

// Service interface for ProcessPaymentHandler handler
type ProcessPaymentHandlerService interface {
	/*
	   ProcessPayment Process payment

	   Process payment and notify user if transaction is finished successfully. You can optionally provide `priceIncludingVAT`and `currency` in the request body to check if the price the user has seen is still correct.
	*/
	ProcessPayment(context.Context, ProcessPaymentResponseWriter, *ProcessPaymentRequest) error
}

// Legacy Interface.
// Use this if you want to fully implement a service.
type Service interface {
	GetPaymentMethodsHandlerService
	CreatePaymentMethodSEPAHandlerService
	DeletePaymentMethodHandlerService
	AuthorizePaymentMethodHandlerService
	DeletePaymentTokenHandlerService
	GetPaymentMethodsIncludingCreditCheckHandlerService
	GetPaymentMethodsIncludingPaymentTokenHandlerService
	ProcessPaymentHandlerService
}

// DeletePaymentTokenHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func DeletePaymentTokenHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(DeletePaymentTokenHandlerService); ok {
		return DeletePaymentTokenHandler(service, authBackend)
	} else {
		return fallback
	}
}

// AuthorizePaymentMethodHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func AuthorizePaymentMethodHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(AuthorizePaymentMethodHandlerService); ok {
		return AuthorizePaymentMethodHandler(service, authBackend)
	} else {
		return fallback
	}
}

// CreatePaymentMethodSEPAHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func CreatePaymentMethodSEPAHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(CreatePaymentMethodSEPAHandlerService); ok {
		return CreatePaymentMethodSEPAHandler(service, authBackend)
	} else {
		return fallback
	}
}

// DeletePaymentMethodHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func DeletePaymentMethodHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(DeletePaymentMethodHandlerService); ok {
		return DeletePaymentMethodHandler(service, authBackend)
	} else {
		return fallback
	}
}

// ProcessPaymentHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func ProcessPaymentHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(ProcessPaymentHandlerService); ok {
		return ProcessPaymentHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetPaymentMethodsIncludingCreditCheckHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetPaymentMethodsIncludingCreditCheckHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetPaymentMethodsIncludingCreditCheckHandlerService); ok {
		return GetPaymentMethodsIncludingCreditCheckHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetPaymentMethodsIncludingPaymentTokenHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetPaymentMethodsIncludingPaymentTokenHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetPaymentMethodsIncludingPaymentTokenHandlerService); ok {
		return GetPaymentMethodsIncludingPaymentTokenHandler(service, authBackend)
	} else {
		return fallback
	}
}

// GetPaymentMethodsHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetPaymentMethodsHandlerWithFallbackHelper(service interface{}, fallback http.Handler, authBackend AuthorizationBackend) http.Handler {
	if service, ok := service.(GetPaymentMethodsHandlerService); ok {
		return GetPaymentMethodsHandler(service, authBackend)
	} else {
		return fallback
	}
}

/*
Router implements: PACE Payment API

Welcome to the PACE Payment API documentation.
This API is responsible for managing payment methods for users as well as authorizing payments on behalf of PACE services.
*/
func Router(service interface{}, authBackend AuthorizationBackend) *mux.Router {
	router := mux.NewRouter()
	authBackend.InitOAuth2(cfgOAuth2)
	authBackend.InitOpenID(cfgOpenID)
	authBackend.InitProfileKey(cfgProfileKey)
	// Subrouter s1 - Path: /pay
	s1 := router.PathPrefix("/pay").Subrouter()
	s1.Methods("DELETE").Path("/beta/payment-methods/{paymentMethodId}/paymentTokens/{paymentTokenId}").Name("DeletePaymentToken").Handler(DeletePaymentTokenHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("POST").Path("/beta/payment-methods/{paymentMethodId}/authorize").Name("AuthorizePaymentMethod").Handler(AuthorizePaymentMethodHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("POST").Path("/beta/payment-methods/sepa-direct-debit").Name("CreatePaymentMethodSEPA").Handler(CreatePaymentMethodSEPAHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("DELETE").Path("/beta/payment-methods/{paymentMethodId}").Name("DeletePaymentMethod").Handler(DeletePaymentMethodHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("POST").Path("/beta/transaction/{pathDecimal}").Name("ProcessPayment").Handler(ProcessPaymentHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/payment-methods").Queries("include", "creditCheck").Name("GetPaymentMethodsIncludingCreditCheck").Handler(GetPaymentMethodsIncludingCreditCheckHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/payment-methods").Queries("include", "paymentToken").Name("GetPaymentMethodsIncludingPaymentToken").Handler(GetPaymentMethodsIncludingPaymentTokenHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	s1.Methods("GET").Path("/beta/payment-methods").Name("GetPaymentMethods").Handler(GetPaymentMethodsHandlerWithFallbackHelper(service, router.NotFoundHandler, authBackend))
	return router
}

/*
Router implements: PACE Payment API

Welcome to the PACE Payment API documentation.
This API is responsible for managing payment methods for users as well as authorizing payments on behalf of PACE services.
*/
func RouterWithFallback(service interface{}, authBackend AuthorizationBackend, fallback http.Handler) *mux.Router {
	router := mux.NewRouter()
	authBackend.InitOAuth2(cfgOAuth2)
	authBackend.InitOpenID(cfgOpenID)
	authBackend.InitProfileKey(cfgProfileKey)
	// Subrouter s1 - Path: /pay
	s1 := router.PathPrefix("/pay").Subrouter()
	s1.Methods("DELETE").Path("/beta/payment-methods/{paymentMethodId}/paymentTokens/{paymentTokenId}").Name("DeletePaymentToken").Handler(DeletePaymentTokenHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("POST").Path("/beta/payment-methods/{paymentMethodId}/authorize").Name("AuthorizePaymentMethod").Handler(AuthorizePaymentMethodHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("POST").Path("/beta/payment-methods/sepa-direct-debit").Name("CreatePaymentMethodSEPA").Handler(CreatePaymentMethodSEPAHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("DELETE").Path("/beta/payment-methods/{paymentMethodId}").Name("DeletePaymentMethod").Handler(DeletePaymentMethodHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("POST").Path("/beta/transaction/{pathDecimal}").Name("ProcessPayment").Handler(ProcessPaymentHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/payment-methods").Queries("include", "creditCheck").Name("GetPaymentMethodsIncludingCreditCheck").Handler(GetPaymentMethodsIncludingCreditCheckHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/payment-methods").Queries("include", "paymentToken").Name("GetPaymentMethodsIncludingPaymentToken").Handler(GetPaymentMethodsIncludingPaymentTokenHandlerWithFallbackHelper(service, fallback, authBackend))
	s1.Methods("GET").Path("/beta/payment-methods").Name("GetPaymentMethods").Handler(GetPaymentMethodsHandlerWithFallbackHelper(service, fallback, authBackend))
	return router
}
