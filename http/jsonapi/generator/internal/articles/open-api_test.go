// Code generated by github.com/pace/bricks DO NOT EDIT.
package articles

import (
	"context"
	errors1 "errors"
	mux "github.com/gorilla/mux"
	opentracing "github.com/opentracing/opentracing-go"
	runtime "github.com/pace/bricks/http/jsonapi/runtime"
	errors "github.com/pace/bricks/maintenance/errors"
	metrics "github.com/pace/bricks/maintenance/metric/jsonapi"
	"net/http"
	"reflect"
)

// CommentLinks ...
type CommentLinks struct {
	Href string `json:"href,omitempty" jsonapi:"attr,href,omitempty" valid:"optional"` // Link to comment
}

// Comment ...
type Comment struct {
	ID    string `jsonapi:"primary,Comment,omitempty" valid:"uuid,optional"`
	Text  string `json:"text,omitempty" jsonapi:"attr,text,omitempty" valid:"required"`
	User  string `json:"user,omitempty" jsonapi:"attr,user,omitempty" valid:"required"`
	Links *CommentLinks
}

// Comments ...
type Comments []*Comment

// InlineRef ...
type InlineRef struct {
	ID        string                 `jsonapi:"primary,InlineRef,omitempty" valid:"uuid,optional"`
	Maptype1  map[string]interface{} `json:"maptype1,omitempty" jsonapi:"attr,maptype1,omitempty" valid:"-"`
	Maptype2  map[string]string      `json:"maptype2,omitempty" jsonapi:"attr,maptype2,omitempty" valid:"-"`
	Something string                 `json:"something,omitempty" jsonapi:"attr,something,omitempty" valid:"optional"`
}

// MapType1 ...
type MapType1 map[string]interface{}

// MapType3 ...
type MapType3 map[string]*Comment

// MapTypeBool ...
type MapTypeBool map[string]bool

// MapTypeInt ...
type MapTypeInt map[string]int64

// MapTypeNumber ...
type MapTypeNumber map[string]float32

// MapTypeString ...
type MapTypeString map[string]string

/*
GetArticleCommentsHandler handles request/response marshaling and validation for

	Get /api/articles/{uuid}/relationships/comments
*/
func GetArticleCommentsHandler(service GetArticleCommentsHandlerService) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("GetArticleCommentsHandler", w, r)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "GetArticleCommentsHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := getArticleCommentsResponseWriter{
			ResponseWriter: metrics.NewMetric("articles", "/api/articles/{uuid}/relationships/comments", w, r),
		}
		request := GetArticleCommentsRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamUuid,
			Location: runtime.ScanInPath,
			Input:    vars["uuid"],
			Name:     "uuid",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Invoke service that implements the business logic
		err := service.GetArticleComments(ctx, &writer, &request)
		select {
		case <-ctx.Done():
			if ctx.Err() != nil {
				// Context cancellation should not be reported if it's the request context
				w.WriteHeader(499)
				if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
					// Report unclean error handling (err != context err) to sentry
					errors.Handle(ctx, err)
				}
			}
		default:
			if err != nil {
				errors.HandleError(err, "GetArticleCommentsHandler", w, r)
			}
		}
	})
}

/*
UpdateArticleCommentsHandler handles request/response marshaling and validation for

	Patch /api/articles/{uuid}/relationships/comments
*/
func UpdateArticleCommentsHandler(service UpdateArticleCommentsHandlerService) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("UpdateArticleCommentsHandler", w, r)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "UpdateArticleCommentsHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := updateArticleCommentsResponseWriter{
			ResponseWriter: metrics.NewMetric("articles", "/api/articles/{uuid}/relationships/comments", w, r),
		}
		request := UpdateArticleCommentsRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamUuid,
			Location: runtime.ScanInPath,
			Input:    vars["uuid"],
			Name:     "uuid",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		ok, data := runtime.UnmarshalMany(w, r, reflect.TypeOf(new(Comment)))
		if ok {
			// Move the data
			for _, elem := range data {
				request.Content = append(request.Content, elem.(*Comment))
			}
			// Invoke service that implements the business logic
			err := service.UpdateArticleComments(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "UpdateArticleCommentsHandler", w, r)
				}
			}
		}
	})
}

/*
UpdateArticleInlineTypeHandler handles request/response marshaling and validation for

	Patch /api/articles/{uuid}/relationships/inline
*/
func UpdateArticleInlineTypeHandler(service UpdateArticleInlineTypeHandlerService) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("UpdateArticleInlineTypeHandler", w, r)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "UpdateArticleInlineTypeHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := updateArticleInlineTypeResponseWriter{
			ResponseWriter: metrics.NewMetric("articles", "/api/articles/{uuid}/relationships/inline", w, r),
		}
		request := UpdateArticleInlineTypeRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamUuid,
			Location: runtime.ScanInPath,
			Input:    vars["uuid"],
			Name:     "uuid",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.UpdateArticleInlineType(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "UpdateArticleInlineTypeHandler", w, r)
				}
			}
		}
	})
}

/*
UpdateArticleInlineRefHandler handles request/response marshaling and validation for

	Patch /api/articles/{uuid}/relationships/inlineref
*/
func UpdateArticleInlineRefHandler(service UpdateArticleInlineRefHandlerService) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("UpdateArticleInlineRefHandler", w, r)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "UpdateArticleInlineRefHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := updateArticleInlineRefResponseWriter{
			ResponseWriter: metrics.NewMetric("articles", "/api/articles/{uuid}/relationships/inlineref", w, r),
		}
		request := UpdateArticleInlineRefRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamUuid,
			Location: runtime.ScanInPath,
			Input:    vars["uuid"],
			Name:     "uuid",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.UpdateArticleInlineRef(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				if err != nil {
					errors.HandleError(err, "UpdateArticleInlineRefHandler", w, r)
				}
			}
		}
	})
}

/*
GetArticleCommentsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type GetArticleCommentsResponseWriter interface {
	http.ResponseWriter
	Comments(Comments)
	NoContent()
	NotFound(error)
}
type getArticleCommentsResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *getArticleCommentsResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// NoContent responds with empty response (HTTP code 204)
func (w *getArticleCommentsResponseWriter) NoContent() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// Comments responds with jsonapi marshaled data (HTTP code 200)
func (w *getArticleCommentsResponseWriter) Comments(data Comments) {
	runtime.Marshal(w, data, 200)
}

/*
GetArticleCommentsRequest is a standard http.Request extended with the
un-marshaled content object
*/
type GetArticleCommentsRequest struct {
	Request   *http.Request `valid:"-"`
	ParamUuid string        `valid:"required"`
}

/*
UpdateArticleCommentsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type UpdateArticleCommentsResponseWriter interface {
	http.ResponseWriter
	NoContent()
	NotFound(error)
}
type updateArticleCommentsResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *updateArticleCommentsResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// NoContent responds with empty response (HTTP code 204)
func (w *updateArticleCommentsResponseWriter) NoContent() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// UpdateArticleCommentsRequest ...
type UpdateArticleCommentsRequest struct {
	Request   *http.Request `valid:"-"`
	Content   Comments      `valid:"-"`
	ParamUuid string        `valid:"required"`
}

/*
UpdateArticleInlineTypeResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type UpdateArticleInlineTypeResponseWriter interface {
	http.ResponseWriter
	NoContent()
	NotFound(error)
}
type updateArticleInlineTypeResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *updateArticleInlineTypeResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// NoContent responds with empty response (HTTP code 204)
func (w *updateArticleInlineTypeResponseWriter) NoContent() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// UpdateArticleInlineTypeContent ...
type UpdateArticleInlineTypeContent []*UpdateArticleInlineTypeContentItem

// UpdateArticleInlineTypeContentItem ...
type UpdateArticleInlineTypeContentItem struct {
	ID        string `jsonapi:"primary,InlineType,omitempty" valid:"uuid,optional"`
	Something string `json:"something,omitempty" jsonapi:"attr,something,omitempty" valid:"optional"`
}

// UpdateArticleInlineTypeRequest ...
type UpdateArticleInlineTypeRequest struct {
	Request   *http.Request                  `valid:"-"`
	Content   UpdateArticleInlineTypeContent `valid:"-"`
	ParamUuid string                         `valid:"required"`
}

/*
UpdateArticleInlineRefResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type UpdateArticleInlineRefResponseWriter interface {
	http.ResponseWriter
	NoContent()
	NotFound(error)
}
type updateArticleInlineRefResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *updateArticleInlineRefResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// NoContent responds with empty response (HTTP code 204)
func (w *updateArticleInlineRefResponseWriter) NoContent() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// UpdateArticleInlineRefContent ...
type UpdateArticleInlineRefContent []*UpdateArticleInlineRefContentItem

// UpdateArticleInlineRefContentItem ...
type UpdateArticleInlineRefContentItem struct {
	ID        string                 `jsonapi:"primary,InlineRef,omitempty" valid:"uuid,optional"`
	Maptype1  map[string]interface{} `json:"maptype1,omitempty" jsonapi:"attr,maptype1,omitempty" valid:"-"`
	Maptype2  map[string]string      `json:"maptype2,omitempty" jsonapi:"attr,maptype2,omitempty" valid:"-"`
	Something string                 `json:"something,omitempty" jsonapi:"attr,something,omitempty" valid:"optional"`
}

// UpdateArticleInlineRefRequest ...
type UpdateArticleInlineRefRequest struct {
	Request   *http.Request                 `valid:"-"`
	Content   UpdateArticleInlineRefContent `valid:"-"`
	ParamUuid string                        `valid:"required"`
}

// Service interface for GetArticleCommentsHandler handler
type GetArticleCommentsHandlerService interface {
	// GetArticleComments Gets the Article's Comments
	GetArticleComments(context.Context, GetArticleCommentsResponseWriter, *GetArticleCommentsRequest) error
}

// Service interface for UpdateArticleCommentsHandler handler
type UpdateArticleCommentsHandlerService interface {
	// UpdateArticleComments Updates the Article with Comment relationships
	UpdateArticleComments(context.Context, UpdateArticleCommentsResponseWriter, *UpdateArticleCommentsRequest) error
}

// Service interface for UpdateArticleInlineTypeHandler handler
type UpdateArticleInlineTypeHandlerService interface {
	// UpdateArticleInlineType
	UpdateArticleInlineType(context.Context, UpdateArticleInlineTypeResponseWriter, *UpdateArticleInlineTypeRequest) error
}

// Service interface for UpdateArticleInlineRefHandler handler
type UpdateArticleInlineRefHandlerService interface {
	// UpdateArticleInlineRef
	UpdateArticleInlineRef(context.Context, UpdateArticleInlineRefResponseWriter, *UpdateArticleInlineRefRequest) error
}

// Legacy Interface.
// Use this if you want to fully implement a service.
type Service interface {
	GetArticleCommentsHandlerService
	UpdateArticleCommentsHandlerService
	UpdateArticleInlineTypeHandlerService
	UpdateArticleInlineRefHandlerService
}

// GetArticleCommentsHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func GetArticleCommentsHandlerWithFallbackHelper(service interface{}, fallback http.Handler) http.Handler {
	if service, ok := service.(GetArticleCommentsHandlerService); ok {
		return GetArticleCommentsHandler(service)
	} else {
		return fallback
	}
}

// UpdateArticleCommentsHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func UpdateArticleCommentsHandlerWithFallbackHelper(service interface{}, fallback http.Handler) http.Handler {
	if service, ok := service.(UpdateArticleCommentsHandlerService); ok {
		return UpdateArticleCommentsHandler(service)
	} else {
		return fallback
	}
}

// UpdateArticleInlineTypeHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func UpdateArticleInlineTypeHandlerWithFallbackHelper(service interface{}, fallback http.Handler) http.Handler {
	if service, ok := service.(UpdateArticleInlineTypeHandlerService); ok {
		return UpdateArticleInlineTypeHandler(service)
	} else {
		return fallback
	}
}

// UpdateArticleInlineRefHandlerWithFallbackHelper helper that checks if the given service fulfills the interface. Returns fallback handler if not, otherwise returns matching handler.
func UpdateArticleInlineRefHandlerWithFallbackHelper(service interface{}, fallback http.Handler) http.Handler {
	if service, ok := service.(UpdateArticleInlineRefHandlerService); ok {
		return UpdateArticleInlineRefHandler(service)
	} else {
		return fallback
	}
}

/*
Router implements: Articles Test Service

Articles Test Service
*/
func Router(service interface{}) *mux.Router {
	router := mux.NewRouter()
	// Subrouter s1 - Path:
	s1 := router.PathPrefix("").Subrouter()
	s1.Methods("GET").Path("/api/articles/{uuid}/relationships/comments").Name("GetArticleComments").Handler(GetArticleCommentsHandlerWithFallbackHelper(service, router.NotFoundHandler))
	s1.Methods("PATCH").Path("/api/articles/{uuid}/relationships/comments").Name("UpdateArticleComments").Handler(UpdateArticleCommentsHandlerWithFallbackHelper(service, router.NotFoundHandler))
	s1.Methods("PATCH").Path("/api/articles/{uuid}/relationships/inline").Name("UpdateArticleInlineType").Handler(UpdateArticleInlineTypeHandlerWithFallbackHelper(service, router.NotFoundHandler))
	s1.Methods("PATCH").Path("/api/articles/{uuid}/relationships/inlineref").Name("UpdateArticleInlineRef").Handler(UpdateArticleInlineRefHandlerWithFallbackHelper(service, router.NotFoundHandler))
	return router
}

/*
Router implements: Articles Test Service

Articles Test Service
*/
func RouterWithFallback(service interface{}, fallback http.Handler) *mux.Router {
	router := mux.NewRouter()
	// Subrouter s1 - Path:
	s1 := router.PathPrefix("").Subrouter()
	s1.Methods("GET").Path("/api/articles/{uuid}/relationships/comments").Name("GetArticleComments").Handler(GetArticleCommentsHandlerWithFallbackHelper(service, fallback))
	s1.Methods("PATCH").Path("/api/articles/{uuid}/relationships/comments").Name("UpdateArticleComments").Handler(UpdateArticleCommentsHandlerWithFallbackHelper(service, fallback))
	s1.Methods("PATCH").Path("/api/articles/{uuid}/relationships/inline").Name("UpdateArticleInlineType").Handler(UpdateArticleInlineTypeHandlerWithFallbackHelper(service, fallback))
	s1.Methods("PATCH").Path("/api/articles/{uuid}/relationships/inlineref").Name("UpdateArticleInlineRef").Handler(UpdateArticleInlineRefHandlerWithFallbackHelper(service, fallback))
	return router
}
