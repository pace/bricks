// Code generated by github.com/pace/bricks DO NOT EDIT.
package articles

import (
	"context"
	errors1 "errors"
	mux "github.com/gorilla/mux"
	opentracing "github.com/opentracing/opentracing-go"
	runtime "github.com/pace/bricks/http/jsonapi/runtime"
	errors "github.com/pace/bricks/maintenance/errors"
	metrics "github.com/pace/bricks/maintenance/metric/jsonapi"
	"net/http"
	"reflect"
)

// Comment ...
type Comment struct {
	ID   string `jsonapi:"primary,Comment,omitempty" valid:"uuid,optional"`
	Text string `json:"text,omitempty" jsonapi:"attr,text,omitempty" valid:"required"`
	User string `json:"user,omitempty" jsonapi:"attr,user,omitempty" valid:"required"`
}

// Comments ...
type Comments []*Comment

// InlineRef ...
type InlineRef struct {
	ID        string                 `jsonapi:"primary,InlineRef,omitempty" valid:"uuid,optional"`
	Maptype1  map[string]interface{} `json:"maptype1,omitempty" jsonapi:"attr,maptype1,omitempty" valid:"-"`
	Maptype2  map[string]string      `json:"maptype2,omitempty" jsonapi:"attr,maptype2,omitempty" valid:"-"`
	Something string                 `json:"something,omitempty" jsonapi:"attr,something,omitempty" valid:"optional"`
}

// MapType1 ...
type MapType1 map[string]interface{}

// MapType3 ...
type MapType3 map[string]*Comment

// MapTypeBool ...
type MapTypeBool map[string]bool

// MapTypeInt ...
type MapTypeInt map[string]int64

// MapTypeNumber ...
type MapTypeNumber map[string]float32

// MapTypeString ...
type MapTypeString map[string]string

/*
UpdateArticleCommentsHandler handles request/response marshaling and validation for
 Patch /api/articles/{uuid}/relationships/comments
*/
func UpdateArticleCommentsHandler(service Service) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("UpdateArticleCommentsHandler", w, r)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "UpdateArticleCommentsHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := updateArticleCommentsResponseWriter{
			ResponseWriter: metrics.NewMetric("articles", "/api/articles/{uuid}/relationships/comments", w, r),
		}
		request := UpdateArticleCommentsRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamUuid,
			Location: runtime.ScanInPath,
			Input:    vars["uuid"],
			Name:     "uuid",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		ok, data := runtime.UnmarshalMany(w, r, reflect.TypeOf(new(Comment)))
		if ok {
			// Move the data
			for _, elem := range data {
				request.Content = append(request.Content, elem.(*Comment))
			}
			// Invoke service that implements the business logic
			err := service.UpdateArticleComments(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				errors.HandleError(err, "UpdateArticleCommentsHandler", w, r)
			}
		}
	})
}

/*
UpdateArticleInlineTypeHandler handles request/response marshaling and validation for
 Patch /api/articles/{uuid}/relationships/inline
*/
func UpdateArticleInlineTypeHandler(service Service) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("UpdateArticleInlineTypeHandler", w, r)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "UpdateArticleInlineTypeHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := updateArticleInlineTypeResponseWriter{
			ResponseWriter: metrics.NewMetric("articles", "/api/articles/{uuid}/relationships/inline", w, r),
		}
		request := UpdateArticleInlineTypeRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamUuid,
			Location: runtime.ScanInPath,
			Input:    vars["uuid"],
			Name:     "uuid",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.UpdateArticleInlineType(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				errors.HandleError(err, "UpdateArticleInlineTypeHandler", w, r)
			}
		}
	})
}

/*
UpdateArticleInlineRefHandler handles request/response marshaling and validation for
 Patch /api/articles/{uuid}/relationships/inlineref
*/
func UpdateArticleInlineRefHandler(service Service) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		defer errors.HandleRequest("UpdateArticleInlineRefHandler", w, r)

		// Trace the service function handler execution
		handlerSpan, ctx := opentracing.StartSpanFromContext(r.Context(), "UpdateArticleInlineRefHandler")
		defer handlerSpan.Finish()

		// Setup context, response writer and request type
		writer := updateArticleInlineRefResponseWriter{
			ResponseWriter: metrics.NewMetric("articles", "/api/articles/{uuid}/relationships/inlineref", w, r),
		}
		request := UpdateArticleInlineRefRequest{
			Request: r.WithContext(ctx),
		}

		// Scan and validate incoming request parameters
		vars := mux.Vars(r)
		if !runtime.ScanParameters(w, r, &runtime.ScanParameter{
			Data:     &request.ParamUuid,
			Location: runtime.ScanInPath,
			Input:    vars["uuid"],
			Name:     "uuid",
		}) {
			return
		}
		if !runtime.ValidateParameters(w, r, &request) {
			return // invalid request stop further processing
		}

		// Unmarshal the service request body
		if runtime.Unmarshal(w, r, &request.Content) {
			// Invoke service that implements the business logic
			err := service.UpdateArticleInlineRef(ctx, &writer, &request)
			select {
			case <-ctx.Done():
				if ctx.Err() != nil {
					// Context cancellation should not be reported if it's the request context
					w.WriteHeader(499)
					if err != nil && !(errors1.Is(err, context.Canceled) || errors1.Is(err, context.DeadlineExceeded)) {
						// Report unclean error handling (err != context err) to sentry
						errors.Handle(ctx, err)
					}
				}
			default:
				errors.HandleError(err, "UpdateArticleInlineRefHandler", w, r)
			}
		}
	})
}

/*
UpdateArticleCommentsResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type UpdateArticleCommentsResponseWriter interface {
	http.ResponseWriter
	NoContent()
	NotFound(error)
}
type updateArticleCommentsResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *updateArticleCommentsResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// NoContent responds with empty response (HTTP code 204)
func (w *updateArticleCommentsResponseWriter) NoContent() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// UpdateArticleCommentsRequest ...
type UpdateArticleCommentsRequest struct {
	Request   *http.Request `valid:"-"`
	Content   Comments      `valid:"-"`
	ParamUuid string        `valid:"required"`
}

/*
UpdateArticleInlineTypeResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type UpdateArticleInlineTypeResponseWriter interface {
	http.ResponseWriter
	NoContent()
	NotFound(error)
}
type updateArticleInlineTypeResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *updateArticleInlineTypeResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// NoContent responds with empty response (HTTP code 204)
func (w *updateArticleInlineTypeResponseWriter) NoContent() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// UpdateArticleInlineTypeContent ...
type UpdateArticleInlineTypeContent []*UpdateArticleInlineTypeContentItem

// UpdateArticleInlineTypeContentItem ...
type UpdateArticleInlineTypeContentItem struct {
	ID        string `jsonapi:"primary,InlineType,omitempty" valid:"uuid,optional"`
	Something string `json:"something,omitempty" jsonapi:"attr,something,omitempty" valid:"optional"`
}

// UpdateArticleInlineTypeRequest ...
type UpdateArticleInlineTypeRequest struct {
	Request   *http.Request                  `valid:"-"`
	Content   UpdateArticleInlineTypeContent `valid:"-"`
	ParamUuid string                         `valid:"required"`
}

/*
UpdateArticleInlineRefResponseWriter is a standard http.ResponseWriter extended with methods
to generate the respective responses easily
*/
type UpdateArticleInlineRefResponseWriter interface {
	http.ResponseWriter
	NoContent()
	NotFound(error)
}
type updateArticleInlineRefResponseWriter struct {
	http.ResponseWriter
}

// NotFound responds with jsonapi error (HTTP code 404)
func (w *updateArticleInlineRefResponseWriter) NotFound(err error) {
	runtime.WriteError(w, 404, err)
}

// NoContent responds with empty response (HTTP code 204)
func (w *updateArticleInlineRefResponseWriter) NoContent() {
	w.Header().Set("Content-Type", "application/vnd.api+json")
	w.WriteHeader(204)
}

// UpdateArticleInlineRefContent ...
type UpdateArticleInlineRefContent []*UpdateArticleInlineRefContentItem

// UpdateArticleInlineRefContentItem ...
type UpdateArticleInlineRefContentItem struct {
	ID        string                 `jsonapi:"primary,InlineRef,omitempty" valid:"uuid,optional"`
	Maptype1  map[string]interface{} `json:"maptype1,omitempty" jsonapi:"attr,maptype1,omitempty" valid:"-"`
	Maptype2  map[string]string      `json:"maptype2,omitempty" jsonapi:"attr,maptype2,omitempty" valid:"-"`
	Something string                 `json:"something,omitempty" jsonapi:"attr,something,omitempty" valid:"optional"`
}

// UpdateArticleInlineRefRequest ...
type UpdateArticleInlineRefRequest struct {
	Request   *http.Request                 `valid:"-"`
	Content   UpdateArticleInlineRefContent `valid:"-"`
	ParamUuid string                        `valid:"required"`
}

// Service interface for all handlers
type Service interface {
	// UpdateArticleComments Updates the Article with Comment relationships
	UpdateArticleComments(context.Context, UpdateArticleCommentsResponseWriter, *UpdateArticleCommentsRequest) error
	// UpdateArticleInlineType
	UpdateArticleInlineType(context.Context, UpdateArticleInlineTypeResponseWriter, *UpdateArticleInlineTypeRequest) error
	// UpdateArticleInlineRef
	UpdateArticleInlineRef(context.Context, UpdateArticleInlineRefResponseWriter, *UpdateArticleInlineRefRequest) error
}

/*
Router implements: Articles Test Service

Articles Test Service
*/
func Router(service Service) *mux.Router {
	router := mux.NewRouter()
	// Subrouter s1 - Path:
	s1 := router.PathPrefix("").Subrouter()
	s1.Methods("PATCH").Path("/api/articles/{uuid}/relationships/comments").Handler(UpdateArticleCommentsHandler(service)).Name("UpdateArticleComments")
	s1.Methods("PATCH").Path("/api/articles/{uuid}/relationships/inline").Handler(UpdateArticleInlineTypeHandler(service)).Name("UpdateArticleInlineType")
	s1.Methods("PATCH").Path("/api/articles/{uuid}/relationships/inlineref").Handler(UpdateArticleInlineRefHandler(service)).Name("UpdateArticleInlineRef")
	return router
}
